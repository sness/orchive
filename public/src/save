------------------------------ Layer.hx ------------------------------

	// Load in the image data for a layer
	public function loadImage() {
		var image_url = _url + "image.jpg";
		trace("Loading image for layer = " + image_url);

		// Image
		_image = new Loader();
		_image.visible = false;
		_image.contentLoaderInfo.addEventListener(Event.INIT, initListener);
		_image.load(new URLRequest(image_url));

	}

	// sness - Eventually this will be a two dimensional array or perhaps tree
	// structure
	private var _image : Loader;     // image associated with this layer


------------------------------ LayerView.hx ------------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.display.Bitmap;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.geom.Rectangle;


class LayerView extends Sprite {

	var _well : Sprite;
	var background : Shape;

	var _height : Int;
	var _width  : Int;

	// A container to hold the LayerViewItems
	var _items_container : Sprite;

	// A mask to just show the LayerViewItems that are inside the boundaries
	// of _items_container
	var _items_container_mask : Shape;

	// An array of all the LayerViewItems
	private var _layer_view_items : Array<LayerViewItem>;

	var _parent_layer_window:LayerWindow;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	var _trackRect : Rectangle;

	public function new(x_:Int, y_:Int, width_:Int, height_:Int, parent_layer_window_:LayerWindow) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_parent_layer_window = parent_layer_window_;

		_layer_view_items = new Array();

		_zoom = 1.0;
		_zoom_increment = 1.1;

		// Create a well to hold everything
		_well = new Sprite();

 		addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);
 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUp);

		// Create the background
 		background = new Shape();
   		background.graphics.beginFill(0xFFFFFF,1);
   		background.graphics.moveTo(0,0);
   		background.graphics.lineTo(_width,0);
   		background.graphics.lineTo(_width,_height);
   		background.graphics.lineTo(0,_height);
   		background.graphics.lineTo(0,0);
 		_well.addChild(background);

		// Create the items_container
 		_items_container = new Sprite();
   		_items_container.graphics.moveTo(0,0);
   		_items_container.graphics.lineTo(_width,0);
   		_items_container.graphics.lineTo(_width,_height);
   		_items_container.graphics.lineTo(0,_height);
   		_items_container.graphics.lineTo(0,0);
 		_well.addChild(_items_container);

		// Create the mask
 		_items_container_mask = new Shape();
   		_items_container_mask.graphics.beginFill(0xFFFFFF,1);
   		_items_container_mask.graphics.moveTo(0,0);
   		_items_container_mask.graphics.lineTo(_width,0);
   		_items_container_mask.graphics.lineTo(_width,_height);
   		_items_container_mask.graphics.lineTo(0,_height);
   		_items_container_mask.graphics.lineTo(0,0);
		_well.addChild(_items_container_mask);
		_items_container.mask = _items_container_mask;

		createTrackRect();

		this.addChild(_well);
	}

 	function mouseOver (e:MouseEvent):Void {
	}

 	function mouseOut (e:MouseEvent):Void {
	}

 	function mouseDown (e:MouseEvent):Void {
		this.startDrag(false,_trackRect);
	}

 	function mouseUp (e:MouseEvent):Void {
		this.stopDrag();
	}

	private function initListener (e:Event):Void {
		createTrackRect();
		redraw();
	}

	public function redraw ():Void {
		// 		trace("_parent_layer_window.layers=" + _parent_layer_window._layers.length);
		//		trace("_layer_view_items=" + _layer_view_items.length);
		if (_layer_view_items.length > 0) {
			for(n in _layer_view_items) {
				n.setZoom(_zoom);
				n.redraw();
			}
		}
	}

	// sness - For now, just delete all the LayerControlLines and make them again
	public function update ():Void {
		trace("updating");
		
		// Delete all the items
		for(i in 0..._items_container.numChildren) {
			_items_container.removeChildAt(0);
		}

		// Create them all again
		for (i in 0..._parent_layer_window._layers.length) {
			var item:LayerViewItem = new LayerViewItem(0,0,_width,_height,_parent_layer_window,_parent_layer_window._layers[i]);
			_items_container.addChild(item);
			_layer_view_items.push(item);
		}

	}

	public function zoomView(delta:Float) {
		if (delta < 0) {
			_zoom *= (1.0 / _zoom_increment);
		} else {
			_zoom *= _zoom_increment;
		}
		if (_zoom < 1.0) {
			_zoom = 1.0;
		}
 		if (_zoom > 7.5) {
 			_zoom = 7.5;
 		}
		trace("_zoom=" + _zoom);
	}

	// Create the rectangle that constrains where we can drag the thumb
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
		_trackRect = new Rectangle(0, 0, _width, 0); 
	}

}

------------------------------ TestPaneIntegration.hx ------------------------------

// 		// The analysis popup window
// 		_analysis_popup_window = new AnalysisPopupWindow(0,0,1000,700);
// 		_well.addChild(_analysis_popup_window);


------------------------------ TestPaneIntegration.hx ------------------------------

  		// The play/pause buttons
  		_play_button = new PlayButton(200,540,40,22);
  		_play_button.addEventListener(MouseEvent.CLICK, togglePlay);
  		_well.addChild(_play_button);


------------------------------ TestPaneIntegration.hx ------------------------------

	private static function progressbarEventListener(e:Event):Void {
		trace("progressbar event=(" + _progress_bar._position + ")");
		_sound_player.stop();
		_sound_position = _progress_bar._position;
		_sound_player.play(_sound_position);
	}
	
------------------------------ TestPaneIntegration.hx ------------------------------

	static private function mainMouseDown(e:Event):Void {
// 		trace("mousedown");
// 		if (e.target == _progress_bar._well) {
// 			stopSound();
// 		}
	}

	static private function mainMouseUp(e:Event):Void {
// 		trace("mouseup");
//  		if (_progress_bar._mouse_down) {
//  			_sound_position = _progress_bar._position;
//   			playSound();
//  		}
	}

------------------------------ TestPaneIntegration.hx ------------------------------

//
// Test the integration of PaneWindows, MenuBars, ControlBars and
// AnalysisPopupWindows.
//

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.ProgressEvent;
import flash.events.IOErrorEvent;
import flash.media.Sound;
import flash.media.SoundChannel;
import flash.net.URLRequest;

class TestPaneIntegration
{

	static var _well : Sprite;
	static var _menubar:MenuBar;
	static var _controlbar:ControlBar;
	static var _pane_window:PaneWindow;

	static var _sound_player : SoundPlayer;
	static var _volume_slider : VolumeSlider;
 	static var _time_indicator : TimeIndicator;
	static var _progress_bar : ProgressBar;

	// sness - Shouldn't this be part of SoundPlayer, or perhaps GlobalSettings?
	static var _sound_state : Int; // Are we currently playing the sound?

	static var _sound_position : Float; // The current playback position (0.0 - length_of_song in milliseconds)
	static var _sound_loaded : Float; // The amount of data that has been loaded (0.0 - length_of_song in milliseconds)

	// sness - Shouldn't this be part of ProgressBar, or perhaps GlobalSettings?
	static var _progress_bar_down : Bool; // Is the mouse down in the progress_bar?


	static var _analysis_popup_window:AnalysisPopupWindow;

	static var _r : TestPaneIntegration;

	static var _index : Int = 0;


	function new(root) {
	}

	public static var recording_id : String; // The id of the Recording in the database

	static function main ()
	{

		// Figure out the prefix of the filename we are looking at
		if (flash.Lib.current.loaderInfo.parameters.recording_id != null) {
			recording_id = flash.Lib.current.loaderInfo.parameters.recording_id;
		} else {
			// If is undefined, we are in the standalone player, so just choose
			// a favorite file for debugging.
			recording_id = "1";
		}

		// Setup the main Timer object 
		//
		// sness - Lowering this makes the slider move more smoothly, but not
		// sure what the downsides of reducing this are, and how low I should
		// have it set.  The other option is to have a fast timer and a slow
		// timer running in tandem.
		var t = new haxe.Timer(5);
		t.run = onTimer;

		// Listen to events on the stage
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mainMouseDown);
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mainMouseUp);
		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		// The SoundPlayer that loads and plays the MP3 file
		_sound_player = new SoundPlayer();
		_sound_state = 0;
		_sound_position = 0;
		_sound_loaded = 0;

		// Create a well to hold everything
		_well = new Sprite();
		_well.name = "main._well";

		// The control bar
		_controlbar = new ControlBar(200,20,1000,40);
		_well.addChild(_controlbar);

		// Listen for control bar events
        _controlbar.addEventListener(ControlBar.REWINDSTART_EVENT,rewindstartEventListener);
        _controlbar.addEventListener(ControlBar.REWIND_EVENT,rewindEventListener);
		_controlbar.addEventListener(ControlBar.PLAYPAUSE_EVENT,playpauseEventListener);
        _controlbar.addEventListener(ControlBar.FFWD_EVENT,ffwdEventListener);
        _controlbar.addEventListener(ControlBar.FFWDEND_EVENT,ffwdendEventListener);

		// The pane window
		_pane_window = new PaneWindow(200,50,1000,450);
		_well.addChild(_pane_window);

		// The menu bar
		_menubar = new MenuBar(200,0,1000,20);
		_well.addChild(_menubar);

		// The progress bar
  		_progress_bar = new ProgressBar(200,500,800,40,_sound_player);
  		_well.addChild(_progress_bar);

		// Listen for progress bar events
		_progress_bar.addEventListener(ProgressBar.NEWPOSITION_EVENT,newPositionListener);

  		// The volume slider
  		_volume_slider = new VolumeSlider(1040,520,100,20);
  		_well.addChild(_volume_slider);

  		// The time indicator
  		_time_indicator = new TimeIndicator(1040,500,100,20);
  		_well.addChild(_time_indicator);

		flash.Lib.current.addChild(_well);

	}

	private static function newPositionListener(e:Event):Void {
		trace("newposition");
		_sound_player.stop();
		_sound_position = _progress_bar._position;
		playSound();
	}
 
	private static function rewindstartEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = 0.0;
		playSound();
	}

	private static function rewindEventListener(e:Event):Void {
		_sound_player.stop();
		// sness - Is 30000 a good number to rewind by?
		_sound_position -= 30000.0;
		playSound();
	}

	private static function playpauseEventListener(e:Event):Void {
		trace("a _sound_state="+_sound_state);
		if (_sound_state == 1) {
  			stopSound();
		} else {
  			playSound();
		}
		trace("b _sound_state="+_sound_state);
		trace("playpause");
	}

	private static function ffwdEventListener(e:Event):Void {
		trace("ffwd");
		_sound_player.stop();
		_sound_position += 30000.0;
		playSound();
	}

	static private function ffwdendEventListener(e:Event):Void {
		trace("ffwd_end");
		_sound_player.stop();
		_sound_position = _sound_player.length();
		playSound();
	}

	static private function mainMouseDown(e:Event):Void {
// 		trace("mousedown");
// 		if (e.target == _progress_bar._well) {
// 			stopSound();
// 		}
	}

	static private function mainMouseUp(e:Event):Void {
// 		trace("mouseup");
//  		if (_progress_bar._mouse_down) {
//  			_sound_position = _progress_bar._position;
//   			playSound();
//  		}
	}

 	public static function playSound():Void {
		trace("playsound");
		_sound_player.play(_sound_position);
		_sound_state = 1;
	}

	public static function stopSound():Void {
		trace("stopsound");
		_sound_player.stop();
		_sound_state = 0;
	}

	static private function mainKeyDown(e:KeyboardEvent):Void {

 		if (e.keyCode == 65) {
 			_pane_window.makeNewPane();
 			_index += 1;
 			redraw();
 		}

	}


	static private function mainKeyUp(e:KeyboardEvent):Void {
	}


	private static function redraw ():Void {
		_pane_window.redraw();
	}

	/***********************************************************************/
	/*  The main coordinating function that looks at the status of all the */
	/*  objects and updates the other objects based on the current state.  */
	/***********************************************************************/
	static function onTimer() {
		// Current position in the song
		if (_sound_state == 1) {
			_sound_position = _sound_player.getPosition();
		}
		_sound_loaded = _sound_player.getLoaded();

 		// Volume
 		if (_sound_state == 1) {
 			_sound_player.setVolume(_volume_slider.getValue());
 		}

 		// Time indicator
 		_time_indicator.value = _sound_position;
 		if (_progress_bar._mouse_down) {
 			_time_indicator.value = _progress_bar._position;
 		}
 		_time_indicator.redraw();

 		// Progress bar
		if (!_progress_bar._mouse_down) {
			_progress_bar._position = _sound_position;
		}
 		_progress_bar._loaded = _sound_loaded;
		_progress_bar.redraw();

		if (_sound_position > _sound_player.length()) {
			stopSound();
			_sound_position = 0.0;
		}
		

		trace("_sound_position="+_sound_position);

	}






}


------------------------------ TestPaneIntegration.hx ------------------------------ 

//  			trace(
// 				"left=" + _pane_window._panes[0]._layer_window._layer_view_window._layer_view.left() +
// 				"right=" + _pane_window._panes[0]._layer_window._layer_view_window._layer_view.right());



------------------------------ Annotator.hx ------------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLRequest;
import flash.geom.Point;

class Annotator extends Sprite {

	static var _well:Sprite;

	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_left:Float;
	var _dragger_right:Float;

	static var _height : Float;
	static var _width  : Float;

	static var _mouse_down : Bool;

	public static var annotationArray : Array<Annotation> = [];

	// The current AnnotationExtent that we are dragging
	public static var current_ae : AnnotationExtent;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;

		_mouse_down = false;


		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,0);
		_well.graphics.moveTo(0,0);
		_well.graphics.lineTo(_width,0);
		_well.graphics.lineTo(_width,_height);
		_well.graphics.lineTo(0,_height);
		_well.graphics.lineTo(0,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseReleasedListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

		redraw();
	}

	private function initListener (e:Event):Void {
	}

 	function redraw () {
		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.graphics.beginFill(0xAAAAAA,1);
			_dragger.graphics.moveTo(_dragger_left,0);
			_dragger.graphics.lineTo(_dragger_right,0);
			_dragger.graphics.lineTo(_dragger_right,_height);
			_dragger.graphics.lineTo(_dragger_left,_height);
			_dragger.graphics.lineTo(_dragger_left,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		_dragger_visible = true;
		_dragger_left = e.localX;
		_dragger_right = e.localX;
		_mouse_down = true;
//  		_well.setChildIndex(_dragger, _well.numChildren - 1);
		redraw();
 	}

 	function mouseReleasedListener (e:MouseEvent):Void {
// 		if (AnnotationLabelMenu._mouse_down) {
// 			trace("alm_md=" + AnnotationLabelMenu._mouse_down);
// 			AnnotationLabelMenu._mouse_down = false;
// 			return;
// 		}

// 		if (_mouse_down) {
// 			// If there is a region selected, turn it into an Annotation
// 			createAnnotation(_dragger_left,_dragger_right);
// 			_dragger_visible = false;
// 		}

		_mouse_down = false;
		AnnotationExtent.drag_icon_mouse_down = false;

		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		//
		// sness - Todo - compensate for the position of the Annotator on the stage
		if (AnnotationExtent.drag_icon_mouse_down) {
			current_ae.setPosition(e.stageX);
			redrawAllAnnotations();
			return;
		} 

		if (_mouse_down == true) {
			if (e.stageX < _dragger_left) {
				_dragger_left = e.stageX;
			} else if (e.stageX > _dragger_right) {
				_dragger_right = e.stageX;
			}
			redraw();
		}
	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// Create an annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			createAnnotation(_dragger_left,_dragger_right,e.charCode);
			_dragger_visible = false;
			redraw();
		}
	}

	function createAnnotation(left:Float,right:Float,char:Int) {
		var annotation = new Annotation(left,right,_width,_height,char);
		var i:Int = annotationArray.push(annotation);
		annotation._index = i;
		_well.addChild(annotation);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		
		for (n in annotationArray) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0...annotationArray.length) {
			iRow = 0;
			annotationArray[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != annotationArray[i]._left )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > annotationArray[i]._left ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				annotationArray[i]._row=iRow;
				xUsed[iRow]=annotationArray[i]._left;

				if(xUsed[iRow] < annotationArray[i]._right) 
					xUsed[iRow]=annotationArray[i]._right;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in annotationArray) {
			n._y = start + (n._row * row_height);
		}
		


	}


}


------------------------------ Annotator.hx ------------------------------

 		for (i in 0..._image_urls.length) {
			for (j in 0..._image_urls[i].length) {
				trace("i=" + i + " j=" + j + " _image_urls[i][j]=" + _image_urls[i][j]);
			}
		}

------------------------------ Annotator.hx ------------------------------

** Thu Apr 23 2009 - 09:54:28 AM
   -----------------------------

Before removing _ctrl_key_down

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	static var _well:Sprite;

	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_left:Float;
	var _dragger_right:Float;

	static var _height : Float;
	static var _width  : Float;

	static var _mouse_down : Bool;

	public static var annotationArray : Array<Annotation> = [];

	// The current AnnotationExtent that we are dragging
	public static var current_ae : AnnotationExtent;

	var _ctrl_key_down : Bool; // Is the ctrl key pressed?

	var _visualization_id : String;

	// A Loader to load the index.txt file in
	var _textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	public var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	private var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_visualization_id = visualization_id_;

		_mouse_down = false;
		_ctrl_key_down = false;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
		// sness - Shouldn't it be 0.333 instead of 0.250?
// 		_zoom = 0.250;
 		_zoom = 0.8;
		_zoom_increment = 1.1;

		// Set defaults
		_loaded = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,0);
		_well.graphics.moveTo(0,0);
		_well.graphics.lineTo(_width,0);
		_well.graphics.lineTo(_width,_height);
		_well.graphics.lineTo(0,_height);
		_well.graphics.lineTo(0,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

		//
 		// Get the text file that contains the images to be displayed
		//
		// sness - Fix this next line so that it's not hardcoded
		var url:String = "recordings/1/waveform/index.txt";
		_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_textfile_loader.load(request);
		_textfile_loader.addEventListener(Event.COMPLETE, textFileLoaderCompleteHandler);

 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {
// 		trace("mouse wheel" + e.delta);
 		zoomView(e.delta);
		redraw();
	}


	private function textFileLoaderCompleteHandler(event:Event):Void {
// 		trace("done loading");

		_image_urls = new Array();
		for (i in 0...5) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var zoom_level = Std.parseInt(elements[0]);
  				var index = Std.parseInt(elements[1]);
  				var url = elements[2];
				if (zoom_level != null && index != null) {
					_image_urls[zoom_level][index] = url;
				}
 			}
 		}


// 		// Now that we are done loading the text file, load the image files.
		loadImages();

	}

	public function loadImages():Void {
// 		trace("loadImages()");
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...5) {
 			_images[i] = new Array();
 		}

 		// Load the images
 		for (i in 0..._image_urls.length) {
 			for (j in 0..._image_urls[i].length) {
//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j] = new Loader();
				_images[i][j].visible = false;
				// sness - Moderately ugly hack where I store the x coordinates
				// that I want the content to be at in the name of the loader.
				// By the time we get to initListener, we've lost the array
				// index where we got the x coordinate from.
				_images[i][j].name = Std.string(j * 100);
// 				_images[i][j].name = Std.string(j * 2400);
				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
				_images[i][j].load(new URLRequest(_image_urls[i][j]));
 			}
 		}

		// Load the image from layer_.getImageUrl()

	}

	private function initListener (e:Event):Void {
// 		trace("initListener");
//  		trace("added" + e.target.loader.name);
 		var l:Loader = e.target.loader;
  		_well.addChild(l.content);
 		l.content.visible = true;
		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;
   		_loaded = true;
//  		_parent_layer_window.redraw();
 	}

	public function zoomView(delta:Float) {
		if (delta < 0) {
			_zoom *= (1.0 / _zoom_increment);
		} else {
			_zoom *= _zoom_increment;
		}
		if (_zoom < 0.1) {
			_zoom = 0.1;
		}
 		if (_zoom > 7.5) {
 			_zoom = 7.5;
 		}
// 		trace("_zoom=" + _zoom);
	}

	public function setZoom(zoom:Float) {

		// We need to figure out what images to display based on the zoom level
		// At a zoom level from 0.25-1, we will display the first set, 

		var zoom_level:Int;

		if (zoom < 1) {
			zoom_level = 0;
		} else {
			zoom_level = 1;
		}

// 		trace("zoom_level=" + zoom_level);

 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					_images[i][j].content.visible = false;
				}
			}
		}

 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
 				_images[zoom_level][j].content.visible = true;
 				_images[zoom_level][j].content.scaleX = zoom - (zoom_level * 0.5);
 			}
 		}
	}

 	function redraw () {
		setZoom(_zoom);

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_left,0);
			_dragger.graphics.lineTo(_dragger_right,0);
			_dragger.graphics.lineTo(_dragger_right,_height);
			_dragger.graphics.lineTo(_dragger_left,_height);
			_dragger.graphics.lineTo(_dragger_left,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_left = e.localX;
			_dragger_right = e.localX;
			_mouse_down = true;
			//  		_well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Allow the user to drag the Annotator
		this.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
// 		if (AnnotationLabelMenu._mouse_down) {
// 			trace("alm_md=" + AnnotationLabelMenu._mouse_down);
// 			AnnotationLabelMenu._mouse_down = false;
// 			return;
// 		}

// 		if (_mouse_down) {
// 			// If there is a region selected, turn it into an Annotation
// 			createAnnotation(_dragger_left,_dragger_right);
// 			_dragger_visible = false;
// 		}

		_mouse_down = false;
		AnnotationExtent.drag_icon_mouse_down = false;

		this.stopDrag();

		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent.drag_icon_mouse_down) {
			current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		if (_mouse_down == true) {
			_dragger_left = e.stageX - x;
			redraw();
		}
	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		trace("down");
		if (e.ctrlKey) {
			_ctrl_key_down = true;
		}

		// Create an annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_left and _dragger_right
			if (_dragger_left > _dragger_right) {
				var tmp:Float = _dragger_right;
				_dragger_right = _dragger_left;
				_dragger_left = tmp;
			}

			createAnnotation(_dragger_left,_dragger_right,e.charCode);
			_dragger_visible = false;
			redraw();
		}
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
		_ctrl_key_down = false;
	}

	function createAnnotation(left:Float,right:Float,char:Int) {
		var annotation = new Annotation(left,right,_width,_height,char);
		var i:Int = annotationArray.push(annotation);
		annotation._index = i;
		_well.addChild(annotation);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		
		for (n in annotationArray) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0...annotationArray.length) {
			iRow = 0;
			annotationArray[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != annotationArray[i]._left )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > annotationArray[i]._left ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				annotationArray[i]._row=iRow;
				xUsed[iRow]=annotationArray[i]._left;

				if(xUsed[iRow] < annotationArray[i]._right) 
					xUsed[iRow]=annotationArray[i]._right;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in annotationArray) {
			n._y = start + (n._row * row_height);
		}
		


	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, y, _width + 10000, 0); 
// 		_trackRect = new Rectangle(-800.0, 0, _width + 800, 0); 
	}


}


------------------------------ AnnotationExtent.hx ------------------------------

		_drag_icon.name = "drag icon"; // sness - For debugging, very handy.


------------------------------ GlobalSettings.hx ------------------------------

** Mon Apr 27 2009 - 10:13:25 AM
   -----------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Bitmap;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.net.URLRequest;


class GlobalSettings {

 	public static var CONTROL_EVENT:String = "CONTROL_EVENT";
	public static var PLAYSTATE_EVENT:String = "PLAYSTATE_EVENT";
	public static var CHANGESONG_EVENT:String = "CHANGESONG_EVENT";
	public static var LABELSTATE_EVENT:String = "LABELSTATE_EVENT";

	// The state of how the items are sorted
	// Is an integer, currently in the range of 1...12
	public static var sort_state:Int; 

	// Are the pitches+labels currently being displayed?
	// 0 - labels+pitches
	// 1 - labels only
	public static var label_state:Int;

	// The current play state of the song
	// 0 - Stop
	// 1 - Play
	public static var play_state:Int;

	// Which of the three sound files are we playing?
	// 0 - Voice
	// 1 - Sine
	// 2 - Quantized sine
	public static var current_song:Int;

	public function new() {
		play_state = 0;
	}

	// Are we in the individual playing state?
	public static function playStateIndividual():Bool {
		if (play_state == 0)
			return false;
		else
			return true;
	}

	public static function showLabelsPlusPitches():Bool {
		if (label_state == 0)
			return true;
		else
			return false;
	}

	public static function getCurrentSong():Int {
		return current_song + 1;
	}



}

------------------------------ OrcaAnnotator.hx ------------------------------

** Mon Apr 27 2009 - 10:51:45 AM
   -----------------------------

	// Add a waveform layer to the current active pane
	private static function addWaveformLayerEventListener(e:Event):Void {
		// 		var p:Pane = _pane_window.getActivePane();
		// 		p._layer_window.makeNewLayer("waveform" + _index,"recordings/1/waveform/","image");
	}

	// Add a spectrogram layer to the current active pane
	private static function addSpectrogramLayerEventListener(e:Event):Void {
		// 		var p:Pane = _pane_window.getActivePane();
		// 		p._layer_window.makeNewLayer("spectrogram" + _index,"recordings/1/spectrogram/","image");
	}

	// Add a annotation layer to the current active pane
	private static function addAnnotationLayerEventListener(e:Event):Void {
		// 		var p:Pane = _pane_window.getActivePane();
		// 		p._layer_window.makeNewLayer("annotation" + _index,"recordings/1/annotation/","image");
	}

	// Add another kind of layer to the current active pane
	private static function addOtherLayerEventListener(e:Event):Void {
		// Let the user choose the layer type and display it
		// 		trace("add other layer");
	}


------------------------------ SoundPlayer.hx ------------------------------

	public function changeSong(i:Int,playing:Int):Void {
		var position:Float = 0;
		if (playing == 1) {
			position = sc.position;
			stop();
		}
		current_file = i;
		if (playing == 1)
			play(position);
	}

------------------------------ ProgressBar.hx ------------------------------

** Mon Apr 27 2009 - 11:51:50 AM
   -----------------------------


	private function bits2ms(bits:Int) {
	}

	private function ms2bits(ms:Int) {
	}


------------------------------ Annotator.hx ------------------------------

	public function zoomView(delta:Float) {
		if (delta < 0) {
			_zoom *= (1.0 / _zoom_increment);
		} else {
			_zoom *= _zoom_increment;
		}
		if (_zoom < 0.1) {
			_zoom = 0.1;
		}
 		if (_zoom > 7.5) {
 			_zoom = 7.5;
 		}
	}


------------------------------ Annotator.hx ------------------------------

	public function setZoom(zoom:Float) {

		trace("");
		trace("setZoom=" + zoom);

		// We need to figure out what images to display based on the zoom level
		// At a zoom level from 0.25-1, we will display the first set, 

		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

// 		if (zoom < 1) {
// 			zoom_level = 0;
// 		} else {
// 			zoom_level = 1;
// 		}

		// 		trace("zoom_level=" + zoom_level);

		// Hide everything
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					_images[i][j].content.visible = false;
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
			var zoom_value:Float = zoom - (zoom_level * 0.666);
			trace("zoom_level=" + zoom_level + " zoom_value=" + zoom_value);
 			for (j in 0..._images[zoom_level].length) {
				var shift_x:Float = j * (2400 * zoom_value);
				//trace("j=" + j + " shift_x=" + shift_x);
 				_images[zoom_level][j].content.visible = true;
 				_images[zoom_level][j].content.scaleX = zoom_value;
				_images[zoom_level][j].content.x = shift_x;
 			}
 		}

		for (n in _annotation_array) {

		}
	}


------------------------------ Annotator.hx ------------------------------

It's really close, I've added recentering after zooming, but it's not quite working.

** Tue Apr 28 2009 - 13:19:22 PM
   -----------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_left:Float;
	var _dragger_right:Float;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// A Loader to load the index.txt file in
	var _textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The left, right and center of the current view
	var _view_left:Float;
	var _view_right:Float;
	var _view_center:Float;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;

		_annotation_array = [];

		_mouse_down = false;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
		// sness - Shouldn't it be 0.333 instead of 0.250?
		// 		_zoom = 0.250;
 		_zoom = 0.0;
		_zoom_increment = 0.1;

		// sness - Just setting these to known values for now, should change this
		_view_left = 0;
		_view_right = 2881801;
		_view_center = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,0);
		_well.graphics.moveTo(0,0);
		_well.graphics.lineTo(_width,0);
		_well.graphics.lineTo(_width,_height);
		_well.graphics.lineTo(0,_height);
		_well.graphics.lineTo(0,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

		//
 		// Get the text file that contains the images to be displayed
		//
		var url:String = "web/visualizations/2/index.txt";
		//		var url:String = "web/visualizations/" + OrcaAnnotator._visualization_id + "/index.txt";
// 		trace("url="+url);
		_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_textfile_loader.load(request);
		_textfile_loader.addEventListener(Event.COMPLETE, textFileLoaderCompleteHandler);

 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {
 		zoomView(e.delta);
		setZoom(_zoom);
// 		redraw();
	}


	private function textFileLoaderCompleteHandler(event:Event):Void {

		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var zoom_level = Std.parseInt(elements[0]);
  				var index = Std.parseInt(elements[1]);
  				var url = elements[2];
				if (zoom_level != null && index != null) {
					_image_urls[zoom_level][index] = url;
					_max_loaded += 1;
				}
 			}
 		}

		// Now that we are done loading the text file, load the image files.
		loadImages();

	}

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

 		// Load the images
 		for (i in 0..._image_urls.length) {
 			for (j in 0..._image_urls[i].length) {
				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j] = new Loader();
				_images[i][j].visible = false;
				// sness - Moderately ugly hack where I store the x coordinates
				// that I want the content to be at in the name of the loader.
				// By the time we get to initListener, we've lost the array
				// index where we got the x coordinate from.
				//_images[i][j].name = Std.string(j * 100);
				_images[i][j].name = Std.string(j * 2400);
				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
// 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j].load(new URLRequest(_image_urls[i][j]));
 			}
 		}

// 		setZoom(_zoom);
	}

	private function initListener (e:Event):Void {
 		var l:Loader = e.target.loader;
  		_well.addChildAt(l.content,0);
 		l.content.visible = true;
//  		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;

		_total_loaded += 1;
// 		trace("_total_loaded=" + _total_loaded);
		if (_total_loaded == _max_loaded) {
			_loaded = true;
			setZoom(_zoom);
		}
 	}

	public function zoomView(delta:Float) {
		if (delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
	}

	public function setZoom(zoom:Float) {

// 		trace("");
// 		trace("setZoom=" + zoom);

// 		trace("determineCenter()=" + determineCenter());

// 		trace("left=" + determineLeft() + " right=" + determineRight());

		findEnds(zoom);

		// We need to figure out what images to display based on the zoom level
		// At a zoom level from 0.25-1, we will display the first set, 

		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

// 		if (zoom < 1) {
// 			zoom_level = 0;
// 		} else {
// 			zoom_level = 1;
// 		}

		// 		trace("zoom_level=" + zoom_level);

		// Hide everything
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					_images[i][j].content.visible = false;
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
			var zoom_mod:Float = (zoom - Std.int(zoom));
			var zoom_value:Float = (zoom_mod * 0.666) + 0.333;
// 			trace("zoom_level=" + zoom_level + " zoom_value=" + zoom_value);
 			for (j in 0..._images[zoom_level].length) {
				var shift_x:Float = j * (2400 * zoom_value);
				//trace("j=" + j + " shift_x=" + shift_x);
 				_images[zoom_level][j].content.visible = true;
 				_images[zoom_level][j].content.scaleX = zoom_value;
				_images[zoom_level][j].content.x = shift_x;
 			}
 		}

		for (n in _annotation_array) {

		}
	}

	function findEnds(zoom:Float):Void {
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}
		var zoom_mod:Float = (zoom - Std.int(zoom));
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;
		
// 		trace("zoom_level=" + zoom_level + " zoom_mod=" + zoom_mod + " zoom_value=" + zoom_value);

		var audio_length:Float = GlobalSettings.audio_length;
		var sections:Float = Math.pow(3,zoom_level);
		var multiplier:Float = audio_length / (sections * 2400.0);

		var left:Float = (_orig_x - x) * (1.0 / zoom_value) * multiplier;
		var right:Float = left + (800 * (1.0 / zoom_value) * multiplier);
		var center:Float = left + ((left + right) / 2);
		
		trace("sections=" + sections + " multiplier=" + Std.int(multiplier) + " left=" + Std.int(left) + " right=" + Std.int(right) + " center=" + Std.int(center));

		var old_center:Float = _view_center;

		_view_left = left;
		_view_right = right;
		_view_center = center;

		var old_center_pixels:Float = old_center / multiplier * zoom_value;
		var view_center_pixels:Float = _view_center / multiplier * zoom_value;
		
		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));
     		this.x -= old_center_pixels - view_center_pixels;

	}

 	function redraw () {
// 		setZoom(_zoom);

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_left,0);
			_dragger.graphics.lineTo(_dragger_right,0);
			_dragger.graphics.lineTo(_dragger_right,_height);
			_dragger.graphics.lineTo(_dragger_left,_height);
			_dragger.graphics.lineTo(_dragger_left,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_left = e.localX;
			_dragger_right = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Allow the user to drag the Annotator
		this.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the left edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the left and
		// right ends are swapped.
		if (_mouse_down == true) {
			_dragger_left = e.stageX - x;
			redraw();
		}
	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_left and _dragger_right
			if (_dragger_left > _dragger_right) {
				var tmp:Float = _dragger_right;
				_dragger_right = _dragger_left;
				_dragger_left = tmp;
			}

			createAnnotation(_dragger_left,_dragger_right,e.charCode);
			_dragger_visible = false;
			redraw();
		}
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
	}

	function createAnnotation(left:Float,right:Float,char:Int) {
		var annotation = new Annotation(left,right,_width,_height,char,this);
		var i:Int = _annotation_array.push(annotation);
		annotation._index = i;
		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
		_well.addChild(annotation);
		redrawAllAnnotations();
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._left )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._left ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._left;

				if(xUsed[iRow] < _annotation_array[i]._right) 
					xUsed[iRow]=_annotation_array[i]._right;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, y, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

}


------------------------------ Annotator.hx ------------------------------

Before refactoring to bring out the zoom values to member variables

** Tue Apr 28 2009 - 14:14:13 PM
   -----------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_left:Float;
	var _dragger_right:Float;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// A Loader to load the index.txt file in
	var _textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The left, right and center of the current view
	var _view_left:Float;
	var _view_right:Float;
	var _view_center:Float;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;

		_annotation_array = [];

		_mouse_down = false;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
		// sness - Shouldn't it be 0.333 instead of 0.250?
		// 		_zoom = 0.250;
 		_zoom = 0.0;
		_zoom_increment = 0.1;

		// sness - Just setting these to known values for now, should change this
		_view_left = 0;
		_view_right = 2881801;
		_view_center = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,0);
		_well.graphics.moveTo(0,0);
		_well.graphics.lineTo(_width,0);
		_well.graphics.lineTo(_width,_height);
		_well.graphics.lineTo(0,_height);
		_well.graphics.lineTo(0,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

		//
 		// Get the text file that contains the images to be displayed
		//
		var url:String = "web/visualizations/2/index.txt";
		//		var url:String = "web/visualizations/" + OrcaAnnotator._visualization_id + "/index.txt";
// 		trace("url="+url);
		_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_textfile_loader.load(request);
		_textfile_loader.addEventListener(Event.COMPLETE, textFileLoaderCompleteHandler);

 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {
 		zoomView(e.delta);
		setZoom(_zoom);
// 		redraw();
	}


	private function textFileLoaderCompleteHandler(event:Event):Void {

		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var zoom_level = Std.parseInt(elements[0]);
  				var index = Std.parseInt(elements[1]);
  				var url = elements[2];
				if (zoom_level != null && index != null) {
					_image_urls[zoom_level][index] = url;
					_max_loaded += 1;
				}
 			}
 		}

		// Now that we are done loading the text file, load the image files.
		loadImages();

	}

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

 		// Load the images
 		for (i in 0..._image_urls.length) {
 			for (j in 0..._image_urls[i].length) {
				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j] = new Loader();
				_images[i][j].visible = false;
				// sness - Moderately ugly hack where I store the x coordinates
				// that I want the content to be at in the name of the loader.
				// By the time we get to initListener, we've lost the array
				// index where we got the x coordinate from.
				//_images[i][j].name = Std.string(j * 100);
				_images[i][j].name = Std.string(j * 2400);
				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
// 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j].load(new URLRequest(_image_urls[i][j]));
 			}
 		}

// 		setZoom(_zoom);
	}

	private function initListener (e:Event):Void {
 		var l:Loader = e.target.loader;
  		_well.addChildAt(l.content,0);
 		l.content.visible = true;
//  		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;

		_total_loaded += 1;
// 		trace("_total_loaded=" + _total_loaded);
		if (_total_loaded == _max_loaded) {
			_loaded = true;
			setZoom(_zoom);
		}
 	}

	public function zoomView(delta:Float) {
		if (delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
	}

	public function setZoom(zoom:Float) {

// 		trace("");
// 		trace("setZoom=" + zoom);

// 		trace("determineCenter()=" + determineCenter());

// 		trace("left=" + determineLeft() + " right=" + determineRight());

		findEnds(zoom);

		// We need to figure out what images to display based on the zoom level
		// At a zoom level from 0.25-1, we will display the first set, 

		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

// 		if (zoom < 1) {
// 			zoom_level = 0;
// 		} else {
// 			zoom_level = 1;
// 		}

		// 		trace("zoom_level=" + zoom_level);

		// Hide everything
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					_images[i][j].content.visible = false;
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
			var zoom_mod:Float = (zoom - Std.int(zoom));
			var zoom_value:Float = (zoom_mod * 0.666) + 0.333;
// 			trace("zoom_level=" + zoom_level + " zoom_value=" + zoom_value);
 			for (j in 0..._images[zoom_level].length) {
				var shift_x:Float = j * (2400 * zoom_value);
				//trace("j=" + j + " shift_x=" + shift_x);
 				_images[zoom_level][j].content.visible = true;
 				_images[zoom_level][j].content.scaleX = zoom_value;
				_images[zoom_level][j].content.x = shift_x;
 			}
 		}

		for (n in _annotation_array) {

		}
	}

	function findEnds(zoom:Float):Void {
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}
		var zoom_mod:Float = (zoom - Std.int(zoom));
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;
		
// 		trace("zoom_level=" + zoom_level + " zoom_mod=" + zoom_mod + " zoom_value=" + zoom_value);

		var audio_length:Float = GlobalSettings.audio_length;
		var sections:Float = Math.pow(3,zoom_level);
		var multiplier:Float = audio_length / (sections * 2400.0);

		var left:Float = (_orig_x - x) * (1.0 / zoom_value) * multiplier;
		var right:Float = left + (800 * (1.0 / zoom_value) * multiplier);
		var center:Float = left + ((left + right) / 2);
		
// 		trace("sections=" + sections + " multiplier=" + Std.int(multiplier) + " left=" + Std.int(left) + " right=" + Std.int(right) + " center=" + Std.int(center));

		var old_center:Float = _view_center;

		_view_left = left;
		_view_right = right;
		_view_center = center;

		var old_center_pixels:Float = old_center / multiplier * zoom_value;
		var view_center_pixels:Float = _view_center / multiplier * zoom_value;
		
// 		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));

		// sness - This seems like it should be really simple, the first zoom works, but
		// then it goes all screwy.
//      		this.x -= old_center_pixels - view_center_pixels;

	}

 	function redraw () {
// 		setZoom(_zoom);

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_left,0);
			_dragger.graphics.lineTo(_dragger_right,0);
			_dragger.graphics.lineTo(_dragger_right,_height);
			_dragger.graphics.lineTo(_dragger_left,_height);
			_dragger.graphics.lineTo(_dragger_left,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_left = e.localX;
			_dragger_right = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Allow the user to drag the Annotator
		this.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the left edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the left and
		// right ends are swapped.
		if (_mouse_down == true) {
			_dragger_left = e.stageX - x;
			redraw();
		}

	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_left and _dragger_right
			if (_dragger_left > _dragger_right) {
				var tmp:Float = _dragger_right;
				_dragger_right = _dragger_left;
				_dragger_left = tmp;
			}

			createAnnotation(_dragger_left,_dragger_right,e.charCode);
			_dragger_visible = false;
			redraw();
		}
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
	}

	function createAnnotation(left:Float,right:Float,char:Int) {

		var left_ms:Float = pix2ms(left);
		var right_ms:Float = pix2ms(right);

		

		var annotation = new Annotation(left,right,_width,_height,char,this);
		var i:Int = _annotation_array.push(annotation);
		annotation._index = i;
		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
		_well.addChild(annotation);
		redrawAllAnnotations();
	}

	// Convert a value in pixels from the current view into milliseconds
	private function pix2ms(pix:Float):Float {
		
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._left )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._left ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._left;

				if(xUsed[iRow] < _annotation_array[i]._right) 
					xUsed[iRow]=_annotation_array[i]._right;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, y, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

}


------------------------------ Annotation.hx ------------------------------

Before refactoring to use milliseconds

** Wed Apr 29 2009 - 10:30:08 AM
   -----------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.net.URLRequest;
import flash.geom.Point;
import flash.text.TextField;
import flash.events.TextEvent;
import flash.text.TextFieldType;
import flash.text.TextFieldAutoSize;
import flash.text.TextFormat;

class Annotation extends Sprite {

 	public static var DELETE_ANNOTATION_EVENT:String = "DELETE_ANNOTATION_EVENT";

	var _well:Sprite;

	var _rect:Sprite;

	var _left_extent:AnnotationExtent;
	var _right_extent:AnnotationExtent;

	public var _index : Int; // The _index of this item in the Annotation

	public var _left:Float;
	public var _right:Float;

	public var _left_ms:Float;
	public var _right_ms:Float;

	var _height : Float;
	var _width  : Float;

	public var _row : Float; // The row in the Annotator for this Annotation
	public var _y : Float;

	var _title : String;

	private var _text:TextField;
	private var _format:TextFormat;

	// Has the user already pressed delete in an empty text field?
	private var _last_char_deleted : Bool;

	public var _annotator : Annotator;

	public function new (left_ms_:Float,right_ms_:Float, width_:Float, height_:Float, char_:Int, annotator_:Annotator) {
		super();

		_left_ms = left_ms_;
		_right_ms = right_ms_;


		_width = width_;
		_height = height_;
		_title = String.fromCharCode(char_);
		_annotator = annotator_;

		// Set a default value for where the label will go
		_y = _height/2 - 1;

		_last_char_deleted = false;

		// A well to hold everything
		_well = new Sprite();
		this.addChild(_well);
		
		_rect = new Sprite();
		_well.addChild(_rect);

		_left_extent = new AnnotationExtent(this,0,_height);
		_well.addChild(_left_extent);

		_right_extent = new AnnotationExtent(this,1,_height);
		_well.addChild(_right_extent);

		_format = new TextFormat();
		_format.font = "Arial";
		_format.size = 12;
 		_format.bold = true;

		// Create a new text field for the title
		_text = new TextField();
		flash.Lib.current.stage.focus = _text;  // Set the focus of the stage to this text field
 		redrawText();
		_well.addChild(_text);

		addEventListener(KeyboardEvent.KEY_DOWN, keyDownListener);
	}


	// The middle of this annotation
	public function centerX():Int {
		return Std.int(_left + ((_right - _left) / 2.0));
	}

	private function initListener (e:Event):Void {
	}

 	public function redraw () {
		_rect.graphics.clear();
		_rect.graphics.lineStyle(1,0x333333);
		_rect.graphics.beginFill(0xAAAAFF,1);
		_rect.graphics.drawRect(_left+10,_y,_right-_left-20,2);

		_left_extent.redraw();
		_right_extent.redraw();
		redrawText();
 	}

	function redrawText():Void {

		_text.background = true;
		_text.backgroundColor = 0xffffff;
		_text.border = true;
		_text.borderColor = 0x000000;
		_text.height = 15; 
   		_text.x = (((_right - _left) / 2.0) + _left) - _text.width / 2;
 		_text.y = _y - 18;
		_text.type = TextFieldType.INPUT;
		_text.autoSize = TextFieldAutoSize.CENTER;
		
		// Add a listener that is called whenever new characters are added
		_text.addEventListener(TextEvent.TEXT_INPUT, textInputListener);
		_text.addEventListener(Event.CHANGE, textChangeListener);

		// The default format for new text
 		_text.defaultTextFormat = _format;

	}

	private function textInputListener (e:TextEvent):Void {
		_title = _text.text;
		_last_char_deleted = false;
	}

	private function textChangeListener (e:Event):Void {
		// Remember when the user deletes the last character, so when they press
		// "backspace" again, we can delete the whole annotation.
		if (e.target.text == "") {
			_last_char_deleted = true;
		}
	}

 	function mouseDownListener (e:MouseEvent):Void {
 	}

 	function mouseReleasedListener (e:MouseEvent):Void {
 	}

 	function keyDownListener (e:KeyboardEvent):Void {
		// If the user already deleted the last character and then presses
		//  "backspace", then she wants to remove the entire annotation.
		if (e.keyCode == 8 && _last_char_deleted) {
			dispatchEvent(new Event(Annotation.DELETE_ANNOTATION_EVENT, true));			
		}
 	}



}


------------------------------ Annotator.hx ------------------------------

	function createAnnotation(left_ms:Float,right_ms:Float,title:String) {

		trace("createAnnotation left_ms=" + left_ms + " right_ms=" + right_ms + " title=" + title);

// 		var left_ms:Float = pix2ms(left);
// 		var right_ms:Float = pix2ms(right);

// 		var annotation = new Annotation(left,right,_width,_height,char,this);
// 		var i:Int = _annotation_array.push(annotation);
// 		annotation._index = i;
// 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
// 		_well.addChild(annotation);
// 		redrawAllAnnotations();
	}


------------------------------ Annotator.hx ------------------------------

** Wed Apr 29 2009 - 15:12:49 PM
   -----------------------------

Before refactoring to make it simpler

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_left:Float;
	var _dragger_right:Float;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The left, right and center of the current view
	var _view_left_ms:Float;
	var _view_right_ms:Float;
	var _view_center_ms:Float;

	// The zoom variables
	var _zoom_level:Int; // The zoom level, an int between 0 and 5
	var _zoom_mod:Float;
	var _zoom_value:Float;
	// _zoom_ms_scale_factor puts all these together into a single number that you
	// can multiply ms by to get pixels
	var _zoom_ms_scale_factor:Float; 
	var _zoom_pix_scale_factor:Float; 

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;

		_annotation_array = [];

		_mouse_down = false;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
		// sness - Shouldn't it be 0.333 instead of 0.250?
		// 		_zoom = 0.250;
 		_zoom = 0.0;
		_zoom_increment = 0.1;
		calcZoom(_zoom);

		// sness - Just setting these to known values for now, should change this
		_view_left_ms = 0;
		_view_right_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,0);
		_well.graphics.moveTo(0,0);
		_well.graphics.lineTo(_width,0);
		_well.graphics.lineTo(_width,_height);
		_well.graphics.lineTo(0,_height);
		_well.graphics.lineTo(0,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		var url:String = "web/visualizations/" + OrcaAnnotator._visualization_id + "/index.txt";
		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);

 		// Get the text file for the annotations
		var url:String = "web/annotations/" + OrcaAnnotator._annotation_id + "/index.txt";
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {
 		zoomView(e.delta);
		setZoom(_zoom);
// 		redraw();
	}


	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {

		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var zoom_level = Std.parseInt(elements[0]);
  				var index = Std.parseInt(elements[1]);
  				var url = elements[2];
				if (zoom_level != null && index != null) {
					_image_urls[zoom_level][index] = url;
					_max_loaded += 1;
				}
 			}
 		}

		// Now that we are done loading the text file, load the image files.
		loadImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
		trace("annotationTextFileLoaderCompleteHandler");

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var left_ms = Std.parseInt(elements[0]);
  				var right_ms = Std.parseInt(elements[1]);
  				var title = elements[2];
				if (left_ms != null && right_ms != null && title != null) { 
					createAnnotation(left_ms,right_ms,title);
				}

			}
		}

		trace("la");

	}

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

 		// Load the images
 		for (i in 0..._image_urls.length) {
 			for (j in 0..._image_urls[i].length) {
				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j] = new Loader();
				_images[i][j].visible = false;
				// sness - Moderately ugly hack where I store the x coordinates
				// that I want the content to be at in the name of the loader.
				// By the time we get to initListener, we've lost the array
				// index where we got the x coordinate from.
				//_images[i][j].name = Std.string(j * 100);
				_images[i][j].name = Std.string(j * 2400);
				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
// 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j].load(new URLRequest(_image_urls[i][j]));
 			}
 		}

// 		setZoom(_zoom);
	}

	private function initListener (e:Event):Void {
 		var l:Loader = e.target.loader;
  		_well.addChildAt(l.content,0);
 		l.content.visible = true;
//  		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;

		_total_loaded += 1;
// 		trace("_total_loaded=" + _total_loaded);
		if (_total_loaded == _max_loaded) {
			_loaded = true;
			setZoom(_zoom);
		}
 	}

	public function zoomView(delta:Float) {
		if (delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
	}

	public function setZoom(zoom:Float) {
 		calcZoom(zoom);

		// Hide everything
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					_images[i][j].content.visible = false;
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
// 			trace("zoom_level=" + zoom_level + " _zoom_value=" + _zoom_value);
 			for (j in 0..._images[_zoom_level].length) {
				var shift_x:Float = j * (2400 * _zoom_value);
				//trace("j=" + j + " shift_x=" + shift_x);
 				_images[_zoom_level][j].content.visible = true;
 				_images[_zoom_level][j].content.scaleX = _zoom_value;
				_images[_zoom_level][j].content.x = shift_x;
 			}
 		}

		// Get each annotation to update it's left and right ends
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	function calcZoom(zoom:Float):Void {
		// The zoom level, an int between 0 and 5
		_zoom_level = Std.int(zoom);
		if (_zoom_level > 5) {
			_zoom_level = 5;
		}
		// Just the fractional part of zoom
		_zoom_mod = (zoom - _zoom_level);
		// The actual amount we are zooming the images by
		_zoom_value = (_zoom_mod * 0.666) + 0.333;

// 		trace("_zoom_level=" + _zoom_level + " _zoom_mod=" + _zoom_mod + " _zoom_value=" + _zoom_value);

		var audio_length:Float = GlobalSettings.audio_length;
		var sections:Float = Math.pow(3,_zoom_level);
		var multiplier:Float = audio_length / (sections * 2400.0);

		// _zoom_ms_scale_factor puts all these together into a single number that you
		// can multiply ms by to get pixels
// 		trace("_zoom_mod=" + _zoom_mod + " audio_length=" + audio_length + " sections=" + sections);
		_zoom_ms_scale_factor = _zoom_value / (audio_length / (sections * 2400.0));

		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * _zoom_value);

// 		trace("calcZoom()::_zoom_ms_scale_factor=" + _zoom_ms_scale_factor);

		var left:Float = (_orig_x - x) * (1.0 / _zoom_value) * multiplier;
		var right:Float = left + (800 * (1.0 / _zoom_value) * multiplier);
		var center:Float = left + ((left + right) / 2);
		
// 		trace("sections=" + sections + " multiplier=" + Std.int(multiplier) + " left=" + Std.int(left) + " right=" + Std.int(right) + " center=" + Std.int(center));

		var old_center:Float = _view_center_ms;

		_view_left_ms = left;
		_view_right_ms = right;
		_view_center_ms = center;

		var old_center_pixels:Float = old_center / multiplier * _zoom_value;
		var view_center_pixels:Float = _view_center_ms / multiplier * _zoom_value;
		
// 		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));

		// sness - This seems like it should be really simple, the first zoom works, but
		// then it goes all screwy.
//      		this.x -= old_center_pixels - view_center_pixels;



	}

 	function redraw () {
// 		setZoom(_zoom);

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_left,0);
			_dragger.graphics.lineTo(_dragger_right,0);
			_dragger.graphics.lineTo(_dragger_right,_height);
			_dragger.graphics.lineTo(_dragger_left,_height);
			_dragger.graphics.lineTo(_dragger_left,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_left = e.localX;
			_dragger_right = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Allow the user to drag the Annotator
		this.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the left edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the left and
		// right ends are swapped.
		if (_mouse_down == true) {
			_dragger_left = e.stageX - x;
			redraw();
		}

// 		trace("_dragger_left=" + _dragger_left + " _dragger_right=" + _dragger_right);

	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_left and _dragger_right
			if (_dragger_left > _dragger_right) {
				var tmp:Float = _dragger_right;
				_dragger_right = _dragger_left;
				_dragger_left = tmp;
			}

			var dragger_left_ms = pix2ms(_dragger_left);
			var dragger_right_ms = pix2ms(_dragger_right);

			createAnnotation(_dragger_left,_dragger_right,String.fromCharCode(e.charCode));
			_dragger_visible = false;
			redraw();
		}
	}

	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
// 		trace("_zoom_ms_scale_factor=" + _zoom_ms_scale_factor);
		return ms * _zoom_ms_scale_factor;
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
	}

	function createAnnotation(left_ms:Float,right_ms:Float,title:String) {

 		var annotation = new Annotation(left_ms,right_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
 		redrawAllAnnotations();
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._left )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._left ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._left;

				if(xUsed[iRow] < _annotation_array[i]._right) 
					xUsed[iRow]=_annotation_array[i]._right;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, y, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

}


------------------------------ Annotator.hx ------------------------------

** Wed Apr 29 2009 - 17:47:01 PM
   -----------------------------

Before making images load just when they need to

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

 		// Load the images
 		for (i in 0..._image_urls.length) {
 			for (j in 0..._image_urls[i].length) {
				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j] = new Loader();
				_images[i][j].visible = false;
				// sness - Moderately ugly hack where I store the x coordinates
				// that I want the content to be at in the name of the loader.
				// By the time we get to initListener, we've lost the array
				// index where we got the x coordinate from.
				//_images[i][j].name = Std.string(j * 100);
				_images[i][j].name = Std.string(j * 2400);
				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
// 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
				_images[i][j].load(new URLRequest(_image_urls[i][j]));
 			}
 		}

// 		setZoom(_zoom);
	}


------------------------------ Annotator.hx ------------------------------

** Thu Apr 30 2009 - 17:40:46 PM
   -----------------------------

It's working!  Triple yay!

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_left:Float;
	var _dragger_right:Float;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The left, right and center of the current view
	var _view_left_ms:Float;
	var _view_right_ms:Float;
	var _view_center_ms:Float;

	// _zoom_ms_scale_factor puts all these together into a single number that you
	// can multiply ms by to get pixels
	var _zoom_ms_scale_factor:Float; 
	var _zoom_pix_scale_factor:Float; 

	var _images_ready : Bool;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;

		_annotation_array = [];

		_mouse_down = false;


		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
 		_zoom = 0.0;
		_zoom_increment = 0.1;
		setZoom(_zoom);

		// sness - Just setting these to known values for now, should change this
		_view_left_ms = 0;
		_view_right_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFF00,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		var url:String = "web/visualizations/" + OrcaAnnotator._visualization_id + "/index.txt";
		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);

 		// Get the text file for the annotations
		var url:String = "web/annotations/" + OrcaAnnotator._annotation_id + "/index.txt";
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {

		if (e.delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
		setZoom(_zoom);
		// 		redraw();
	}


	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {

		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var zoom_level = Std.parseInt(elements[0]);
  				var index = Std.parseInt(elements[1]);
  				var url = elements[2];
				if (zoom_level != null && index != null) {
					_image_urls[zoom_level][index] = url;
					_max_loaded += 1;
				}
 			}
 		}

		// Now that we are done loading the text file, load the image files.
		loadImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
		// 		trace("annotationTextFileLoaderCompleteHandler");

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var left_ms = Std.parseInt(elements[0]);
  				var right_ms = Std.parseInt(elements[1]);
  				var title = elements[2];
				if (left_ms != null && right_ms != null && title != null) { 
					createAnnotation(left_ms,right_ms,title);
				}

			}
		}

	}

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

		//  		// Load the images
		//  		for (i in 0..._image_urls.length) {
		//  			for (j in 0..._image_urls[i].length) {
		// 				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
		// 				_images[i][j] = new Loader();
		// 				_images[i][j].visible = false;
		// 				// sness - Moderately ugly hack where I store the x coordinates
		// 				// that I want the content to be at in the name of the loader.
		// 				// By the time we get to initListener, we've lost the array
		// 				// index where we got the x coordinate from.
		// 				//_images[i][j].name = Std.string(j * 100);
		// 				_images[i][j].name = Std.string(j * 2400);
		// 				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
		// // 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
		// 				_images[i][j].load(new URLRequest(_image_urls[i][j]));
		//  			}
		//  		}

		// 		setZoom(_zoom);

		_images_ready = true;

		loadNecessaryImages();
	}

	private function initListener (e:Event):Void {
 		var l:Loader = e.target.loader;
  		_well.addChildAt(l.content,0);
 		l.content.visible = true;
		//  		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;

		_total_loaded += 1;
		// 		trace("_total_loaded=" + _total_loaded);
// 		if (_total_loaded == _max_loaded) {
			_loaded = true;
			setZoom(_zoom);
// 		}
 	}

	public function calcEdges():Void {
		_view_left_ms = (_orig_x - x) * _zoom_pix_scale_factor;
		_view_right_ms = _view_left_ms + (800 * _zoom_pix_scale_factor);
		_view_center_ms = _view_left_ms + ((_view_left_ms + _view_right_ms) / 2);

		// 		trace("_view_left_ms=" + Std.int(_view_left_ms) + " _view_right_ms=" + Std.int(_view_right_ms) + " _view_center_ms=" + Std.int(_view_center_ms));

		loadNecessaryImages();
	}

	public function loadNecessaryImages():Void {

		if (_images_ready) {
			var zoom_level:Int = Std.int(_zoom);
			if (zoom_level > 5) {
				zoom_level = 5;
			}

			// How many different images are at this zoom level
			var sections:Float = Math.pow(3,zoom_level);
			var audio_length:Float = GlobalSettings.audio_length;
			var section_size:Float = audio_length / sections;
		
// 			trace("------------------------------");
//  			trace("zoom_level=" + zoom_level + "_view_left_ms=" + Std.int(_view_left_ms) + " _view_right_ms=" + Std.int(_view_right_ms) + " _view_center_ms=" + Std.int(_view_center_ms));

			// Figure out which images have their left or right edges within _view_left_ms and _view_right_ms
			var left:Float = 0;
			var right:Float = section_size;
			for (i in 0..._image_urls[zoom_level].length) {
// 				trace("left=" + left + " vlm=" + _view_left_ms + "right=" + right + " vrm=" + _view_right_ms);
				if (((left >= _view_left_ms) && (left <= _view_right_ms)) ||
					((right >= _view_left_ms) && (right <= _view_right_ms))) {
					if (_images[zoom_level][i] == null) {
						loadImage(zoom_level,i);
					}
				}
				left = right;
				right += section_size;
			}

		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
		_images[zoom_level][index] = new Loader();
		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, initListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));
	}


	public function setZoom(zoom:Float) {

		// The zoom level, an int between 0 and 5
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

		// Just the fractional part of zoom_level
		var zoom_mod:Float = (zoom - zoom_level);

		// The actual amount we are zooming the images by
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.audio_length;
		
		// How many different images are at this zoom level
		var sections:Float = Math.pow(3,zoom_level);

		// _zoom_ms_scale_factor puts all these together into a single number
		// that you can multiply ms by to get pixels
		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// _zoom_pix_scale_factor puts all these together into a single number
		// that you can multiply pixels by to get ms
		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * zoom_value);

		// Calculate the positions of the left and edges that are currently visible
		calcEdges();

		// 		var old_center:Float = _view_center_ms;

		// 		_view_left_ms = left;
		// 		_view_right_ms = right;
		// 		_view_center_ms = center;

		// 		var old_center_pixels:Float = old_center / multiplier * zoom_value;
		// 		var view_center_pixels:Float = _view_center_ms / multiplier * zoom_value;
		
		// 		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));

		// sness - This seems like it should be really simple, the first zoom works, but
		// then it goes all screwy.
		//      		this.x -= old_center_pixels - view_center_pixels;

		// Hide all the images
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
				if (_images[zoom_level][j] != null && _images[zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * zoom_value);
					_images[zoom_level][j].content.visible = true;
					_images[zoom_level][j].content.scaleX = zoom_value;
					_images[zoom_level][j].content.x = shift_x;
				}
 			}
 		}

		// Get each annotation to update it's left and right ends
		for (n in _annotation_array) {
			n.redraw();
		}
	}

 	function redraw () {
		// 		setZoom(_zoom);

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_left,0);
			_dragger.graphics.lineTo(_dragger_right,0);
			_dragger.graphics.lineTo(_dragger_right,_height);
			_dragger.graphics.lineTo(_dragger_left,_height);
			_dragger.graphics.lineTo(_dragger_left,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_left = e.localX;
			_dragger_right = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Allow the user to drag the Annotator
		this.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the left edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the left and
		// right ends are swapped.
		if (_mouse_down == true) {
			_dragger_left = e.stageX - x;
			redraw();
		}

		// 		trace("_dragger_left=" + _dragger_left + " _dragger_right=" + _dragger_right);

		calcEdges();
	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_left and _dragger_right
			if (_dragger_left > _dragger_right) {
				var tmp:Float = _dragger_right;
				_dragger_right = _dragger_left;
				_dragger_left = tmp;
			}

			createAnnotation(pix2ms(_dragger_left),pix2ms(_dragger_right),"");
			_dragger_visible = false;
			redraw();
		}
	}

	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		return ms * _zoom_ms_scale_factor;
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
	}

	function createAnnotation(left_ms:Float,right_ms:Float,title:String) {

 		var annotation = new Annotation(left_ms,right_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
 		redrawAllAnnotations();
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._left )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._left ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._left;

				if(xUsed[iRow] < _annotation_array[i]._right) 
					xUsed[iRow]=_annotation_array[i]._right;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, y, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

}


------------------------------ Annotator.hx ------------------------------

 		// Get the text file for the visualization
		var url:String = "/assets/visualizations/" + OrcaAnnotator._visualization_id + "/index.txt";
		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);

 		// Get the text file for the annotations
		var url:String = "assets/annotations/" + OrcaAnnotator._annotation_id + "/index.txt";
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);


------------------------------ Annotator.hx ------------------------------

** Fri May 15 2009 - 14:13:57 PM
   -----------------------------

   Trying to change things to allow us to reload the images

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	// _zoom_ms_scale_factor puts all these together into a single number that you
	// can multiply ms by to get pixels
	var _zoom_ms_scale_factor:Float; 
	var _zoom_pix_scale_factor:Float; 

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;

		_annotation_array = [];

		_mouse_down = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
 		_zoom = 0.0;
		_zoom_increment = 0.1;
		setZoom(_zoom);

		// sness - Just setting these to known values for now, should change this
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFF00,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {

		if (e.delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
		setZoom(_zoom);
		// 		redraw();
	}


	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {

		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoom_level = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
 //    				trace("url=" + url);
 				if (zoom_level != null && index != null) {
 					_image_urls[zoom_level][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		loadImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
		// 		trace("annotationTextFileLoaderCompleteHandler");

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

		//  		// Load the images
		//  		for (i in 0..._image_urls.length) {
		//  			for (j in 0..._image_urls[i].length) {
		// 				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
		// 				_images[i][j] = new Loader();
		// 				_images[i][j].visible = false;
		// 				// sness - Moderately ugly hack where I store the x coordinates
		// 				// that I want the content to be at in the name of the loader.
		// 				// By the time we get to initListener, we've lost the array
		// 				// index where we got the x coordinate from.
		// 				//_images[i][j].name = Std.string(j * 100);
		// 				_images[i][j].name = Std.string(j * 2400);
		// 				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
		// // 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
		// 				_images[i][j].load(new URLRequest(_image_urls[i][j]));
		//  			}
		//  		}

		// 		setZoom(_zoom);

		_images_ready = true;

		loadNecessaryImages();
	}

	private function initListener (e:Event):Void {
 		var l:Loader = e.target.loader;
  		_well.addChildAt(l.content,0);
 		l.content.visible = true;
		//  		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;

		_total_loaded += 1;
		// 		trace("_total_loaded=" + _total_loaded);
// 		if (_total_loaded == _max_loaded) {
			_loaded = true;
			setZoom(_zoom);
// 		}
 	}

	public function calcEdges():Void {
		_view_start_ms = (_orig_x - x) * _zoom_pix_scale_factor;
		_view_end_ms = _view_start_ms + (800 * _zoom_pix_scale_factor);
		_view_center_ms = _view_start_ms + ((_view_start_ms + _view_end_ms) / 2);

		// 		trace("_view_start_ms=" + Std.int(_view_start_ms) + " _view_end_ms=" + Std.int(_view_end_ms) + " _view_center_ms=" + Std.int(_view_center_ms));

		loadNecessaryImages();
	}

	public function loadNecessaryImages():Void {

		if (_images_ready) {
			var zoom_level:Int = Std.int(_zoom);
			if (zoom_level > 5) {
				zoom_level = 5;
			}

			// How many different images are at this zoom level
			var sections:Float = Math.pow(3,zoom_level);
			var audio_length:Float = GlobalSettings.audio_length;
			var section_size:Float = audio_length / sections;
		
// 			trace("------------------------------");
//  			trace("zoom_level=" + zoom_level + "_view_start_ms=" + Std.int(_view_start_ms) + " _view_end_ms=" + Std.int(_view_end_ms) + " _view_center_ms=" + Std.int(_view_center_ms));

			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = section_size;
			for (i in 0..._image_urls[zoom_level].length) {
// 				trace("start=" + start + " vlm=" + _view_start_ms + "end=" + end + " vrm=" + _view_end_ms);
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms))) {
					if (_images[zoom_level][i] == null) {
						loadImage(zoom_level,i);
					}
				}
				start = end;
				end += section_size;
			}

		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
//  		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
// 		trace("_image_urls[zoom_level][index]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();
		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, initListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));
	}


	public function setZoom(zoom:Float) {

		// The zoom level, an int between 0 and 5
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

		// Just the fractional part of zoom_level
		var zoom_mod:Float = (zoom - zoom_level);

		// The actual amount we are zooming the images by
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.audio_length;
		
		// How many different images are at this zoom level
		var sections:Float = Math.pow(3,zoom_level);

		// _zoom_ms_scale_factor puts all these together into a single number
		// that you can multiply ms by to get pixels
		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// _zoom_pix_scale_factor puts all these together into a single number
		// that you can multiply pixels by to get ms
		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * zoom_value);

		// Calculate the positions of the start and edges that are currently visible
		calcEdges();

		// 		var old_center:Float = _view_center_ms;

		// 		_view_start_ms = start;
		// 		_view_end_ms = end;
		// 		_view_center_ms = center;

		// 		var old_center_pixels:Float = old_center / multiplier * zoom_value;
		// 		var view_center_pixels:Float = _view_center_ms / multiplier * zoom_value;
		
		// 		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));

		// sness - This seems like it should be really simple, the first zoom works, but
		// then it goes all screwy.
		//      		this.x -= old_center_pixels - view_center_pixels;

		// Hide all the images
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
				if (_images[zoom_level][j] != null && _images[zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * zoom_value);
					_images[zoom_level][j].content.visible = true;
					_images[zoom_level][j].content.scaleX = zoom_value;
					_images[zoom_level][j].content.x = shift_x;
				}
 			}
 		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}
	}

 	function redraw () {
		// 		setZoom(_zoom);

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Allow the user to drag the Annotator
		this.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		if (_mouse_down == true) {
			_dragger_start = e.stageX - x;
			redraw();
		}

		// 		trace("_dragger_start=" + _dragger_start + " _dragger_end=" + _dragger_end);

		calcEdges();
	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_start and _dragger_end
			if (_dragger_start > _dragger_end) {
				var tmp:Float = _dragger_end;
				_dragger_end = _dragger_start;
				_dragger_start = tmp;
			}

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		return ms * _zoom_ms_scale_factor;
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
	}

	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {

// 		trace("la3");
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
//  		redrawAllAnnotations();

	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {

		determineAnnotationYPositions();
		for (n in _annotation_array) {
// 			trace("n1=" + n);
			n.redraw();
// 			trace("n2=" + n);
		}
// 		trace("la7");

	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, y, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

	// The center of the Annotator view
	public function setCenter(f:Float):Void {
// 		_center_ms = f;
	}

// 	public function getCenter():Float {
// 		return _center_ms;
// 	}


	// The rectangular playback bar
	public function setPlaybackBar(f:Float):Void {
		_playback_bar_ms = f;
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}

		_saved = true;
	}
	
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	public function loadVisualization() {
		// Load 
		trace("loadVisualization()");
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
	}

	// Called from the main OrcaAnnotator class by Javascript
	public function reloadVisualization() {
		trace("reloadVisualization()");
	}


}


------------------------------ OrcaAnnotator.hx ------------------------------

** Wed May 20 2009 - 11:04:47 AM
   -----------------------------

   Before removing _center_line

//
// Test the integration of PaneWindows, MenuBars, ControlBars and
// AnalysisPopupWindows.
//

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.ProgressEvent;
import flash.events.IOErrorEvent;
import flash.media.Sound;
import flash.media.SoundChannel;
import flash.net.URLRequest;
import flash.external.ExternalInterface;

class OrcaAnnotator
{

	static var _well : Sprite;
	static var _controlbar : ControlBar;
	static var _annotator : Annotator;
// 	static var _center_line:Sprite;

	static var _sound_player : SoundPlayer;
	static var _volume_slider : VolumeSlider;
 	static var _time_indicator : TimeIndicator;
	static var _progress_bar : ProgressBar;
	static var _xml_loader : XMLLoader;

	// sness - Shouldn't this be part of SoundPlayer, or perhaps GlobalSettings?
	static var _sound_state : Int; // Are we currently playing the sound?

	static var _sound_position : Int; // The current playback position (0 - length_of_song in milliseconds)
	static var _sound_loaded : Int; // The amount of data that has been loaded (0 - length_of_song in milliseconds)

	// sness - Shouldn't this be part of ProgressBar, or perhaps GlobalSettings?
	static var _progress_bar_down : Bool; // Is the mouse down in the progress_bar?

	static var _r : OrcaAnnotator;

	static var _index : Int = 0;

	static var _current_time : Int = 0;

	function new(root) {
	}

	public static var _recording_url : String; // The path to Recording assets
	public static var _annotation_url : String; // The path to Annotation assets
	public static var _visualization_url : String; // The path to Visualization assets

	static function main ()
	{
		GlobalSettings.setDefaults();

		// Figure out the prefix of the filename we are looking at
		if (flash.Lib.current.loaderInfo.parameters.recording_url != null) {
			_recording_url = flash.Lib.current.loaderInfo.parameters.recording_url;
			_annotation_url = flash.Lib.current.loaderInfo.parameters.annotation_url;
			_visualization_url = flash.Lib.current.loaderInfo.parameters.visualization_url;
		} else {
			// If is undefined, we are in the standalone player, so just choose
			// a favorite file for debugging.
			_recording_url = "assets/recordings/2003/223A";
 			_annotation_url = "recordings/annotations/1.txt";
 			_visualization_url = "assets/visualizations/2003/223A/waveform";
			GlobalSettings.setAudioLength(2878920.0);
		}

		// Setup the main Timer object 
		var t = new haxe.Timer(5);
		t.run = onTimer;

		// Listen to events on the stage
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mainMouseDown);
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mainMouseUp);
		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		// Load the configuration file
		_xml_loader = new XMLLoader();
		flash.Lib.current.addChild(_xml_loader);

		// The SoundPlayer that loads and plays the MP3 file
		_sound_player = new SoundPlayer();
		_sound_state = 0;
		_sound_position = 0;
		_sound_loaded = 0;

		// Create a well to hold everything
		_well = new Sprite();
		_well.name = "main._well";

		// The control bar
   		_controlbar = new ControlBar(500,5,1000,30);
//   		_controlbar = new ControlBar(0,5,1000,30);
 		_well.addChild(_controlbar);

		// Listen for control bar events
		_controlbar.addEventListener(ControlBar.REWINDSTART_EVENT,rewindstartEventListener);
		_controlbar.addEventListener(ControlBar.REWIND_EVENT,rewindEventListener);
		_controlbar.addEventListener(ControlBar.PLAYPAUSE_EVENT,playpauseEventListener);
		_controlbar.addEventListener(ControlBar.FFWD_EVENT,ffwdEventListener);
		_controlbar.addEventListener(ControlBar.FFWDEND_EVENT,ffwdendEventListener);

		// The annotator
//  		var ann_x:Int = 200;
 		var ann_x:Int = 0;
		var ann_y:Int = 30;
		var ann_width:Int = 800;
		var ann_height:Int = 150;
		_annotator = new Annotator(ann_x,ann_y,ann_width,ann_height,_visualization_url,_sound_player);
 		_well.addChild(_annotator);

// 		// The center line for the Annotator
// 		_center_line = new Sprite();
// 		_center_line.graphics.lineStyle(1,0x333333);		
// 		_center_line.graphics.moveTo((ann_width/2)+ann_x-1,ann_y);
// 		_center_line.graphics.lineTo((ann_width/2)+ann_x+1,ann_y);
// 		_center_line.graphics.lineTo((ann_width/2)+ann_x+1,ann_height+ann_y);
// 		_center_line.graphics.lineTo((ann_width/2)+ann_x-1,ann_height+ann_y);
// 		_center_line.graphics.lineTo((ann_width/2)+ann_x-1,ann_y);
// 		_well.addChild(_center_line);

		// The progress bar
//    		_progress_bar = new ProgressBar(200,180,600,40,_sound_player);
		_progress_bar = new ProgressBar(0,200,600,40,_sound_player);
   		_well.addChild(_progress_bar);

		// Listen for progress bar events
		_progress_bar.addEventListener(ProgressBar.NEWPOSITION_EVENT,newPositionListener);

   		// The volume slider
//    		_volume_slider = new VolumeSlider(840,200,100,20);
		_volume_slider = new VolumeSlider(670,220,100,20);
  		_well.addChild(_volume_slider);

  		// The time indicator
//    		_time_indicator = new TimeIndicator(860,180,100,20);
		_time_indicator = new TimeIndicator(670,200,100,20);
  		_well.addChild(_time_indicator);

		flash.Lib.current.addChild(_well);

   		ExternalInterface.addCallback("visualizationChange", visualizationChange);
   		ExternalInterface.addCallback("followModeChange", followModeChange);

	}

	private static function newPositionListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = _progress_bar.getPosition();
		playSound();
	}
 
	private static function rewindstartEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = 0;
		playSound();
	}

	private static function rewindEventListener(e:Event):Void {
		_sound_player.stop();
		// sness - Is 30000 a good number to rewind by?
		_sound_position -= 30000;
		playSound();
	}

	private static function playpauseEventListener(e:Event):Void {
		if (_sound_state == 1) {
  			stopSound();
		} else {
  			playSound();
		}
	}

	private static function ffwdEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position += 30000;
		playSound();
	}

	static private function ffwdendEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = _sound_player.length();
		playSound();
	}

	static private function mainMouseDown(e:Event):Void {
	}

	static private function mainMouseUp(e:Event):Void {
	}

 	public static function playSound():Void {
		_sound_player.play(_sound_position);
		_sound_state = 1;
	}

	public static function stopSound():Void {
		_sound_player.stop();
		_sound_state = 0;
	}

	static private function mainKeyDown(e:KeyboardEvent):Void {
		if (e.keyCode == 83) {
			_annotator.saveAnnotations();
		}
	}


	static private function mainKeyUp(e:KeyboardEvent):Void {
	}


	private static function redraw ():Void {
	}

	/***********************************************************************/
	/*  The main coordinating function that looks at the status of all the */
	/*  objects and updates the other objects based on the current state.  */
	/***********************************************************************/
	static function onTimer() {
		// Current position in the song
		if (_sound_state == 1) {
			_sound_position = _sound_player.getPosition();
		}
		_sound_loaded = _sound_player.getLoaded();

 		// Volume
 		if (_sound_state == 1) {
 			_sound_player.setVolume(_volume_slider.getValue());
 		}

 		// Time indicator
 		_time_indicator.value = _sound_position;
 		if (_progress_bar._mouse_down) {
 			_time_indicator.value = _progress_bar.getPosition();
 		}
 		_time_indicator.redraw();

 		// Progress bar
		if (!_progress_bar._mouse_down) {
			_progress_bar.setPosition(_sound_position);
		}
 		_progress_bar._loaded = _sound_loaded;
		_progress_bar.redraw();

		if (_sound_position > _sound_player.length()) {
			stopSound();
			_sound_position = 0;
		}

		// Update the ProgressBar reticules based on the x position of each of
		// the LayerViews.
		//
		// sness - This seems to me to be inefficient.  Could we instead do this
		// when the view in the Annotator changes?
  		_progress_bar.setReticle(_annotator.get_start_ms(),_annotator.get_end_ms());

		// Update the position of the annotator for the different kinds of
		// follow playback modes
		_annotator.redraw();


// 		// Every 1000 ticks, check to see if we need to save the annotations
// 		if (_current_time % 1000 == 0) {
// 			if (_annotator.getSaved() == false) {
// 				_annotator.saveAnnotations();
// 			}
// 		}

		_current_time += 1;
	}


	//////////////////////////////////////////////////////////////////////////////////
	//
	// Javascript callback functions
	//
	//////////////////////////////////////////////////////////////////////////////////

	// sness - Remember to add an ExternalInterface.addCallback() to the main loop 
	// for all new functions you add here

	static public function visualizationChange(s:String):Void {
		_visualization_url = s;
		_annotator.reloadVisualization();
	}

	static public function followModeChange(s:String):Void {
		GlobalSettings.setFollowMode(Std.parseInt(s));
	}




}



------------------------------ Annotator.hx ------------------------------

** Wed May 20 2009 - 12:18:04 PM
   -----------------------------

 	public function redraw() {

		//
		// If we are in (followMode == page == 0)
		//
		// - Find what the current position of the playback bar should be
		// - If the playback bar isn't visible, adjust the window so that
		// the playback bar is at the far left edge of the window.
		// - Move the playback bar to the current sound position
		// 
 		if (GlobalSettings.getFollowMode() == 0) {
			var pos:Float = _sound_player.getPosition();
			if (pos < _view_start_ms || pos > _view_end_ms) {
				// Find the new x position of the frame based on this new view center
				_well.x = (_zoom_pix_scale_factor * _orig_x - pos) / _zoom_pix_scale_factor;
// 				trace("_well.x=" + _well.x);
			}
			// trace("pos=" + pos + " ms2pix(pos)=" + ms2pix(pos));
			_playback_bar.x = ms2pix(pos - _view_start_ms);
			calcEdges();
			loadNecessaryImages();
		}

		//
		// If we are in (followMode == scroll == 1)
		//
		// Move the center of the view to be centered on that position
 		if (GlobalSettings.getFollowMode() == 1) {
			// Move the playback_bar to the center of the view
			_playback_bar.x = width / 2;
			// Find the current song position, which will be the new view center
			var pos:Int = _sound_player.getPosition();
			// Find the new x position of the frame based on this new view center
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((pos - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
 		}

		//
		// If we are in (followMode == off == 2)
		//
		// Move the playback bar to the current sound position
 		if (GlobalSettings.getFollowMode() == 2) {
			_playback_bar.x = ms2pix(_sound_player.getPosition());
 		}

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}
 	}


------------------------------ Annotator.hx ------------------------------

** Wed May 20 2009 - 13:10:51 PM
   -----------------------------

Before cleanup

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;
	var _image_container:Sprite;
	var _playback_bar:Sprite;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	// _zoom_ms_scale_factor puts all these together into a single number that you
	// can multiply ms by to get pixels
	var _zoom_ms_scale_factor:Float; 
	var _zoom_pix_scale_factor:Float; 

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	private var _sound_player : SoundPlayer;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;
		_sound_player = sound_player_;

		_annotation_array = [];

		_mouse_down = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.  
 		_zoom = 0.0;
		_zoom_increment = 0.1;
		setZoom(_zoom);

		// sness - Just setting these to known values for now, should change this
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFF00,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

		// The center line for the Annotator
		_playback_bar = new Sprite();
		_playback_bar.graphics.lineStyle(1,0x333333);		
		_playback_bar.graphics.moveTo(0,0);
		_playback_bar.graphics.lineTo(2,0);
		_playback_bar.graphics.lineTo(2,_height);
		_playback_bar.graphics.lineTo(0,_height);
		_playback_bar.graphics.lineTo(0,0);
		_playback_bar.x = _width / 2;
		this.addChild(_playback_bar);

		// A container for all the images we will load
		_image_container = new Sprite();
		_well.addChild(_image_container);

  		_image_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_image_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_image_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
 		_image_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

  		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
  		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
 		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheel);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);


		// The grey dragger that allows the user to create new annotations
		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();
	}

 	function mouseWheel (e:MouseEvent):Void {

		if (e.delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
		setZoom(_zoom);
		// 		redraw();
	}


	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {

// 		trace("visualizationTextFileLoaderCompleteHandler()");

		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoom_level = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
//      				trace("url=" + url);
 				if (zoom_level != null && index != null) {
 					_image_urls[zoom_level][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		loadImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
		// 		trace("annotationTextFileLoaderCompleteHandler");

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	public function loadImages():Void {
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}

		//  		// Load the images
		//  		for (i in 0..._image_urls.length) {
		//  			for (j in 0..._image_urls[i].length) {
		// 				//  				trace("_image_urls[i][j]=" + _image_urls[i][j]);
		// 				_images[i][j] = new Loader();
		// 				_images[i][j].visible = false;
		// 				// sness - Moderately ugly hack where I store the x coordinates
		// 				// that I want the content to be at in the name of the loader.
		// 				// By the time we get to initListener, we've lost the array
		// 				// index where we got the x coordinate from.
		// 				//_images[i][j].name = Std.string(j * 100);
		// 				_images[i][j].name = Std.string(j * 2400);
		// 				_images[i][j].contentLoaderInfo.addEventListener(Event.INIT, initListener);
		// // 				trace("_image_urls[i][j]=" + _image_urls[i][j]);
		// 				_images[i][j].load(new URLRequest(_image_urls[i][j]));
		//  			}
		//  		}

		// 		setZoom(_zoom);

		_images_ready = true;

		loadNecessaryImages();
	}

	private function initListener (e:Event):Void {
 		var l:Loader = e.target.loader;
  		_image_container.addChildAt(l.content,0);
 		l.content.visible = true;
		//  		l.content.alpha = 0.2;
 		l.content.x = Std.parseInt(l.name);
 		// sness - This shifts the image over by 300 pixels.  We need to do this for all
 		// the subimages as well.
 		// 		_image.content.x = 300;

		_total_loaded += 1;
		// 		trace("_total_loaded=" + _total_loaded);
// 		if (_total_loaded == _max_loaded) {
			_loaded = true;
			setZoom(_zoom);
// 		}
 	}

	public function calcEdges():Void {
		if (_well != null) {
			_view_start_ms = (_orig_x - _well.x) * _zoom_pix_scale_factor;
			_view_end_ms = _view_start_ms + (800 * _zoom_pix_scale_factor);
			_view_center_ms = _view_start_ms + ((_view_start_ms + _view_end_ms) / 2);
		}
//  		trace("_view_start_ms=" + Std.int(_view_start_ms) + " _view_end_ms=" + Std.int(_view_end_ms) + " _view_center_ms=" + Std.int(_view_center_ms));

	}

	public function loadNecessaryImages():Void {

		if (_images_ready) {
			var zoom_level:Int = Std.int(_zoom);
			if (zoom_level > 5) {
				zoom_level = 5;
			}

			// How many different images are at this zoom level
			var sections:Float = Math.pow(3,zoom_level);
			var audio_length:Float = GlobalSettings.getAudioLength();
			var section_size:Float = audio_length / sections;
		
// 			trace("------------------------------");
//  			trace("zoom_level=" + zoom_level + "_view_start_ms=" + Std.int(_view_start_ms) + " _view_end_ms=" + Std.int(_view_end_ms) + " _view_center_ms=" + Std.int(_view_center_ms));

			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = section_size;
			for (i in 0..._image_urls[zoom_level].length) {
// 				trace("start=" + start + " vlm=" + _view_start_ms + "end=" + end + " vrm=" + _view_end_ms);
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms))) {
					if (_images[zoom_level][i] == null) {
						loadImage(zoom_level,i);
					}
				}
				start = end;
				end += section_size;
			}

		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
//   		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
//  		trace("_image_urls[zoom_level][index]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();
		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, initListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));
	}


	public function setZoom(zoom:Float) {

		// The zoom level, an int between 0 and 5
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

		// Just the fractional part of zoom_level
		var zoom_mod:Float = (zoom - zoom_level);

		// The actual amount we are zooming the images by
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();
		
		// How many different images are at this zoom level
		var sections:Float = Math.pow(3,zoom_level);

		// _zoom_ms_scale_factor puts all these together into a single number
		// that you can multiply ms by to get pixels
		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// _zoom_pix_scale_factor puts all these together into a single number
		// that you can multiply pixels by to get ms
		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * zoom_value);

		// Calculate the positions of the start and edges that are currently visible
		calcEdges();
		loadNecessaryImages();

		// 		var old_center:Float = _view_center_ms;

		// 		_view_start_ms = start;
		// 		_view_end_ms = end;
		// 		_view_center_ms = center;

		// 		var old_center_pixels:Float = old_center / multiplier * zoom_value;
		// 		var view_center_pixels:Float = _view_center_ms / multiplier * zoom_value;
		
		// 		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));

		// sness - This seems like it should be really simple, the first zoom works, but
		// then it goes all screwy.
		//      		this.x -= old_center_pixels - view_center_pixels;

		// Hide all the images
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
				if (_images[zoom_level][j] != null && _images[zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * zoom_value);
					_images[zoom_level][j].content.visible = true;
					_images[zoom_level][j].content.scaleX = zoom_value;
					_images[zoom_level][j].content.x = shift_x;
				}
 			}
 		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}
	}

 	public function redraw() {

		//
		// If we are in (followMode == (page == 0))
		//
		// - Find what the current position of the playback bar should be
		// - If the playback bar isn't visible, adjust the window so that
		// the playback bar is at the far left edge of the window.
		// - Move the playback bar to the current sound position
		// 
 		if (GlobalSettings.getFollowMode() == 0) {
			var pos:Float = _sound_player.getPosition();
			if (pos < _view_start_ms || pos > _view_end_ms) {
				// Find the new x position of the frame based on this new view center
				_well.x = (_zoom_pix_scale_factor * _orig_x - pos) / _zoom_pix_scale_factor;
			}
			_playback_bar.x = ms2pix(pos - _view_start_ms);
			calcEdges();
			loadNecessaryImages();
		}

		//
		// If we are in (followMode == (scroll == 1))
		//
		// Move the center of the view to be centered on that position
 		if (GlobalSettings.getFollowMode() == 1) {
			// Move the playback_bar to the center of the view
			_playback_bar.x = _width / 2;
			// Find the current song position, which will be the new view center
			var pos:Int = _sound_player.getPosition();
			// Find the new x position of the frame based on this new view center
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((pos - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
			calcEdges();
			loadNecessaryImages();
 		}

		//
		// If we are in (followMode == (off == 2))
		//
		// Move the playback bar to the current sound position
 		if (GlobalSettings.getFollowMode() == 2) {
			_playback_bar.x = ms2pix(_sound_player.getPosition());
 		}

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}
 	}

 	function mouseDownListener (e:MouseEvent):Void {
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

// 		trace("dragging");
		// Allow the user to drag the Annotator
		_well.startDrag(false,_trackRect);


 	}

 	function mouseUpListener (e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener (e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		if (_mouse_down == true) {
			_dragger_start = e.stageX - x;
			redraw();
		}

		// 		trace("_dragger_start=" + _dragger_start + " _dragger_end=" + _dragger_end);

		calcEdges();
		loadNecessaryImages();

	}

	private function mainKeyDown(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_start and _dragger_end
			if (_dragger_start > _dragger_end) {
				var tmp:Float = _dragger_end;
				_dragger_end = _dragger_start;
				_dragger_start = tmp;
			}

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		return ms * _zoom_ms_scale_factor;
	}

	private function mainKeyUp(e:KeyboardEvent):Void {
	}

	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {

// 		trace("la3");
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
//  		redrawAllAnnotations();

	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}

	function redrawAllAnnotations() {

		determineAnnotationYPositions();
		for (n in _annotation_array) {
// 			trace("n1=" + n);
			n.redraw();
// 			trace("n2=" + n);
		}
// 		trace("la7");

	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, 0, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

// 	// The center of the Annotator view
// 	public function setCenter(f:Float):Void {
// 		_center_ms = f;
// 	}

// 	public function getCenter():Float {
// 		return _center_ms;
// 	}


	// The rectangular playback bar
	public function setPlaybackBar(f:Float):Void {
		_playback_bar_ms = f;
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}

		_saved = true;
	}
	
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	public function loadVisualization() {
		// Load 
// 		trace("loadVisualization()");
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
 		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);
	}

	// Called from the main OrcaAnnotator class by Javascript
	public function reloadVisualization() {
// 		trace("reloadVisualization()");

		for(i in 0..._image_container.numChildren) {
			_image_container.removeChildAt(0);
		}

		_images = new Array();
		_image_urls = new Array();
		loadVisualization();
	}

	// Return the leftmost position of the currently visible window
	// in sound position units
	public function get_start_ms():Float {

		calcEdges();

// 		trace("x=" + this.x + " _zoom=" + _zoom);
		
// 		return x * SoundPlayer.static_length() / _zoom;
		return _view_start_ms;
	}

	// Return the rightmost position of the currently visible window
	// in sound position units
	public function get_end_ms():Float {
		return _view_end_ms;
	}

}


------------------------------ Annotator.hx ------------------------------


		// 		var old_center:Float = _view_center_ms;

		// 		_view_start_ms = start;
		// 		_view_end_ms = end;
		// 		_view_center_ms = center;

		// 		var old_center_pixels:Float = old_center / multiplier * zoom_value;
		// 		var view_center_pixels:Float = _view_center_ms / multiplier * zoom_value;
		
		// 		trace("old_center_pixels=" + old_center_pixels + " view_center_pixels=" + view_center_pixels + " diff=" + (old_center_pixels - view_center_pixels));

		// sness - This seems like it should be really simple, the first zoom works, but
		// then it goes all screwy.
		//      		this.x -= old_center_pixels - view_center_pixels;


------------------------------ Annotator.hx ------------------------------

** Wed May 20 2009 - 14:11:49 PM
   -----------------------------

	//
	// sness - These might be useful in the future when multiple Annotators can
	// be on a webpage and each of them can control the playback position of the
	// others.
	//

// 	// The center of the Annotator view
// 	public function setCenter(f:Float):Void {
// 		_center_ms = f;
// 	}

// 	public function getCenter():Float {
// 		return _center_ms;
// 	}


------------------------------ Annotator.hx ------------------------------

** Fri May 22 2009 - 12:12:24 PM
   -----------------------------

Hmm... Predictions as Sprites are causing some problems.

Would it be so bad to make it one big shape?

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;
	var _image_container:Sprite;
	var _prediction_container:Sprite;
	var _playback_bar:Sprite;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The array of all predictions in this Annotator
	var _prediction_array : Array<Prediction>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;
	var _prediction_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	// _zoom_ms_scale_factor puts all these together into a single number that you
	// can multiply ms by to get pixels
	var _zoom_ms_scale_factor:Float; 
	var _zoom_pix_scale_factor:Float; 

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	private var _sound_player : SoundPlayer;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;
		_sound_player = sound_player_;

		_annotation_array = [];
		_prediction_array = [];

		_mouse_down = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.
 		_zoom = 0.0;
		_zoom_increment = 0.1;
		setZoom(_zoom);

		// sness - Just setting these to known values for now, should change
		// this to get the values from GlobalSettings.
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

		// The center line for the Annotator
		_playback_bar = new Sprite();
		_playback_bar.graphics.lineStyle(1,0x333333);		
		_playback_bar.graphics.moveTo(0,0);
		_playback_bar.graphics.lineTo(2,0);
		_playback_bar.graphics.lineTo(2,_height);
		_playback_bar.graphics.lineTo(0,_height);
		_playback_bar.graphics.lineTo(0,0);
		_playback_bar.x = _width / 2;
		this.addChild(_playback_bar);

		// A container for all the annotations we will load
		_image_container = new Sprite();
		_well.addChild(_image_container);

		// A container for all the predictions we will load
		_prediction_container = new Sprite();
		_well.addChild(_prediction_container);


   		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
   		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
  		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);


		_image_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		_image_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_image_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
   		_image_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_prediction_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_prediction_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_prediction_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_prediction_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDownListener);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUpListener);


		// The grey dragger that allows the user to create new annotations
		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);

 		// Get the text file for the predictions
		var url:String = OrcaAnnotator._prediction_url;
		_prediction_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_prediction_textfile_loader.load(request);
		_prediction_textfile_loader.addEventListener(Event.COMPLETE, predictionTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();

	}

	////////////////////////////////////////
	//
	// Listeners
	//
	////////////////////////////////////////

	private function loadImageListener(e:Event):Void {
 		var l:Loader = e.target.loader;
  		_image_container.addChildAt(l.content,0);
 		l.content.visible = true;
 		l.content.x = Std.parseInt(l.name);
		_total_loaded += 1;
		_loaded = true;
		setZoom(_zoom);
 	}


 	function mouseWheelListener(e:MouseEvent):Void {
		if (e.delta < 0) {
			_zoom -= _zoom_increment;
		} else {
			_zoom += _zoom_increment;
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
		setZoom(_zoom);
	}

 	function mouseDownListener(e:MouseEvent):Void {
		trace("down");
		if (e.eventPhase != EventPhase.AT_TARGET)
			return;

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

// 		trace("dragging");
		// Allow the user to drag the Annotator
		_well.startDrag(false,_trackRect);


 	}

 	function mouseUpListener(e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener(e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - _well.x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		if (_mouse_down == true) {
			_dragger_start = e.stageX - _well.x;
			redraw();
		}
		calcEdges();
		loadNecessaryImages();
	}

	private function mainKeyDownListener(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_start and _dragger_end
			if (_dragger_start > _dragger_end) {
				var tmp:Float = _dragger_end;
				_dragger_end = _dragger_start;
				_dragger_start = tmp;
			}

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	private function mainKeyUpListener(e:KeyboardEvent):Void {
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}


	////////////////////////////////////////
	//
	// File load completion handlers
	//
	////////////////////////////////////////

	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {
		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoom_level = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
 				if (zoom_level != null && index != null) {
 					_image_urls[zoom_level][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}
		_images_ready = true;

		loadNecessaryImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	private function predictionTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _prediction_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
  				var confidence = Std.parseFloat(elements[4]);
  				var color = Std.parseInt(elements[5]);
				if (id != null && start_ms != null && end_ms != null && name != null && color != null) { 
					createPrediction(id,start_ms,end_ms,name,confidence,color);
				}
			}
		}
	}

	public function calcEdges():Void {
		if (_well != null) {
			_view_start_ms = (_orig_x - _well.x) * _zoom_pix_scale_factor;
			_view_end_ms = _view_start_ms + (800 * _zoom_pix_scale_factor);
			_view_center_ms = _view_start_ms + ((_view_start_ms + _view_end_ms) / 2);
		}
	}

	public function loadNecessaryImages():Void {
		if (_images_ready) {
			var zoom_level:Int = Std.int(_zoom);
			if (zoom_level > 5) {
				zoom_level = 5;
			}

			// How many different images are at this zoom level
			var sections:Float = Math.pow(3,zoom_level);
			var audio_length:Float = GlobalSettings.getAudioLength();
			var section_size:Float = audio_length / sections;
		
			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = section_size;
			for (i in 0..._image_urls[zoom_level].length) {
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms))) {
					if (_images[zoom_level][i] == null) {
						loadImage(zoom_level,i);
					}
				}
				start = end;
				end += section_size;
			}

		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
//   		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
//  		trace("_image_urls[zoom_level][index]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();
		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, loadImageListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));
	}


	public function setZoom(zoom:Float) {

		calcEdges();
		var old_view_center_ms:Float = _view_center_ms;

		// The zoom level, an int between 0 and 5
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > 5) {
			zoom_level = 5;
		}

		// Just the fractional part of zoom_level
		var zoom_mod:Float = (zoom - zoom_level);

		// The actual amount we are zooming the images by
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();
		
		// How many different images are at this zoom level
		var sections:Float = Math.pow(3,zoom_level);

		// _zoom_ms_scale_factor puts all these together into a single number
		// that you can multiply ms by to get pixels
		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// _zoom_pix_scale_factor puts all these together into a single number
		// that you can multiply pixels by to get ms
		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * zoom_value);

		// Calculate the positions of the start and edges that are currently visible
		loadNecessaryImages();
		calcEdges();

		// Recenter the view on the old center
		
		// sness - This is just about there, but misses zooming in on the center
		// by about 200 pixels too far to the left.  Very strange.  One data
		// point is that the left edge of the Annotator window is at the zoom in
		// point.  Something tricky needs to be done.
		if (!Math.isNaN(old_view_center_ms)) {
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((old_view_center_ms - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
// 			trace("old_view_center_ms=" + old_view_center_ms + " _view_center_ms=" + _view_center_ms + "_well.x=" + _well.x);
		}

		// Hide all the images
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
				if (_images[zoom_level][j] != null && _images[zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * zoom_value);
					_images[zoom_level][j].content.visible = true;
					_images[zoom_level][j].content.scaleX = zoom_value;
					_images[zoom_level][j].content.x = shift_x;
				}
 			}
 		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}
	}

 	public function redraw() {

		//
		// If we are in (followMode == (page == 0))
		//
		// - Find what the current position of the playback bar should be
		// - If the playback bar isn't visible, adjust the window so that
		// the playback bar is at the far left edge of the window.
		// - Move the playback bar to the current sound position
		// 
 		if (GlobalSettings.getFollowMode() == 0) {
			var pos:Float = _sound_player.getPosition();
			if (pos < _view_start_ms || pos > _view_end_ms) {
				// Find the new x position of the frame based on this new view center
				_well.x = (_zoom_pix_scale_factor * _orig_x - pos) / _zoom_pix_scale_factor;
			}
			_playback_bar.x = ms2pix(pos - _view_start_ms);
			calcEdges();
			loadNecessaryImages();
		}

		//
		// If we are in (followMode == (scroll == 1))
		//
		// Move the center of the view to be centered on that position
 		if (GlobalSettings.getFollowMode() == 1) {
			// Move the playback_bar to the center of the view
			_playback_bar.x = _width / 2;
			// Find the current song position, which will be the new view center
			var pos:Int = _sound_player.getPosition();
			// Find the new x position of the frame based on this new view center
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((pos - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
			calcEdges();
			loadNecessaryImages();
 		}

		//
		// If we are in (followMode == (off == 2))
		//
		// Move the playback bar to the current sound position
 		if (GlobalSettings.getFollowMode() == 2) {
			_playback_bar.x = ms2pix(_sound_player.getPosition());
 		}

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}
 	}


	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		return ms * _zoom_ms_scale_factor;
	}

	// Create a new annotation
	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
	}

	// Create a new prediction
	function createPrediction(id:Int,start_ms:Float,end_ms:Float,title:String,confidence:Float,color:Int) {
 		var prediction = new Prediction(id,start_ms,end_ms,title,confidence,color,this);
 		var i:Int = _prediction_array.push(prediction);
 		prediction._index = i;
 		_prediction_container.addChild(prediction);
		trace("added prediction");
	}

	// Redraw all the annotations in _annotation_array
	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-10000.0, 0, _width + 10000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

	// The rectangular playback bar
	public function setPlaybackBar(f:Float):Void {
		_playback_bar_ms = f;
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	// Called when the web server returns a response to us trying to save the
	// annotations.  The web server should return the string "update complete "
	// if everything worked.
	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}
		_saved = true;
	}
	
	// Have all the annotations been saved back to the web server?
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	// Load a specific visualization from the web server, for
	// example, the waveform or spectrogram view
	public function loadVisualization() {
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
 		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);
	}

	// Called from the main OrcaAnnotator class by Javascript when the 
	// user requests to see a different visualization
	public function reloadVisualization() {
		for(i in 0..._image_container.numChildren) {
			_image_container.removeChildAt(0);
		}

		_images = new Array();
		_image_urls = new Array();
		loadVisualization();
	}

	// Return the leftmost position of the currently visible window
	// in sound position units
	public function get_start_ms():Float {
		calcEdges();
		return _view_start_ms;
	}

	// Return the rightmost position of the currently visible window
	// in sound position units
	public function get_end_ms():Float {
		return _view_end_ms;
	}

}

####################################################################################################

** Fri Jul 10 2009 - 16:10:55 PM
   -----------------------------

Before a major refactoring to make it behave more like Sonic Visualiser

------------------------------ ProgressBar.hx ------------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.display.Bitmap;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.filters.ColorMatrixFilter;
import flash.geom.Point;


class ProgressBar extends Sprite {

 	public static var NEWPOSITION_EVENT:String = "NEWPOSITION_EVENT";

	public var _well : Sprite;     // A holder for everything
	private var _slider : Loader;  // The slider indicator
	private var _bar_slider : Loader;  // The bar_slider indicator
	public var _waveform : Loader;     // The waveform picture
	var _loaded_background : Shape; // The background of the loaded bar
	var _loaded_indicator : Shape;  // The progress indicator of the loaded bar

	// A mask to hide any part of the reticles that is outside the ProgressBar
	var _progress_bar_mask : Shape;
	
	public var _reticle : ProgressBarReticle;

	private var _position : Float;  // Position that we are at in the sound file
	public var _loaded : Float;    // Amount of the sound file that is loaded
	private var _ready : Int;      // Have all the Loaders finished loading?

	public var _mouse_down : Bool; // Is the mouse currently down?
	static var _point : Point;
	static var _local_point : Point;

	static var _width  : Int;
	static var _height : Int;

	private var _image_displayed : Int; // Are we displaying the waveform (0) or spectogram (1)

	private var _sound_player : SoundPlayer;

	public function new(x_:Int, y_:Int, width_:Int, height_:Int, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_sound_player = sound_player_;

		_position = 0;
		_loaded = 0;
		_ready = 0;
		_image_displayed = 0;

		addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);
		addEventListener(MouseEvent.MOUSE_MOVE, mouseMove);
  		addEventListener(MouseEvent.MOUSE_UP, mouseUp);

		// Well to hold everything
		_well = new Sprite();

		// Create the mask
 		_progress_bar_mask = new Shape();
   		_progress_bar_mask.graphics.beginFill(0xFFFFFF,1);
   		_progress_bar_mask.graphics.moveTo(0,0);
   		_progress_bar_mask.graphics.lineTo(_width,0);
   		_progress_bar_mask.graphics.lineTo(_width,_height);
   		_progress_bar_mask.graphics.lineTo(0,_height);
   		_progress_bar_mask.graphics.lineTo(0,0);
		_well.addChild(_progress_bar_mask);
		_well.mask = _progress_bar_mask;

		// Slider
		_slider = new Loader();
		_slider.visible = false;
		_slider.contentLoaderInfo.addEventListener(Event.INIT, initListener);
		_slider.load(new URLRequest("/src/library/slider.png"));

		// Waveform
		_waveform = new Loader();
		_waveform.visible = false;
		_waveform.contentLoaderInfo.addEventListener(Event.INIT, initListener);
		_waveform.load(new URLRequest(OrcaAnnotator._recording_url + "/globalview.jpg"));

		// The background of the loaded bar
		_loaded_background = new Shape();
		_loaded_background.graphics.lineStyle(0);
		_loaded_background.graphics.beginFill(0xFFFFFF,0.2);
		_loaded_background.graphics.drawRect(0,0,_width,40);
		_loaded_background.x = 0;
		_loaded_background.y = 0;
		_well.addChild(_loaded_background);

		// The indicator of the loaded bar
		_loaded_indicator = new Shape();
		_loaded_indicator.graphics.lineStyle(0);
		_loaded_indicator.graphics.beginFill(0xFFEEEE,0.2);
		_loaded_indicator.graphics.drawRect(0,0,1,40);
		_loaded_indicator.x = 0;
		_loaded_indicator.y = 0;
		_well.addChild(_loaded_indicator);

		// The reticles
		_reticle = new ProgressBarReticle();
		_well.addChild(_reticle);
		

		addChild(_well);
	}

	private function initListener (e:Event):Void {
  		_well.addChild(_waveform.content);
 		_well.addChild(_slider.content);
		_slider.content.x = -3;
		_ready = 1;

		redraw();
 	}

	function mouseDown (e:MouseEvent):Void {
		// sness - Not sure why this isn't needed anymore
		// 		if (e.target == _well) {
		_mouse_down = true;
		_position = e.localX / _width * _sound_player.length();
		redraw();
		// 		}
 	}

 	function mouseUp (e:MouseEvent):Void {
		// trace("mouseup");
		_mouse_down = false;
 		this.dispatchEvent(new Event(ProgressBar.NEWPOSITION_EVENT, true));
 	}

 	function mouseMove (e:MouseEvent):Void {
		if (_mouse_down == true) {
			if (e.target == _well) {
				_position = e.localX / _width * _sound_player.length();
			}
			if (e.target == this.stage) {
				_point.x = e.localX;
				_point.y = e.localY;
				_local_point = _well.globalToLocal(_point);
				if (_local_point.x > _width) {
					_position = _sound_player.length();
				} else if (_local_point.x < 0) {
					_position = 0.0;
				} else {
					_position = _local_point.x / _width * _sound_player.length();
				}
			}
			redraw();
		}
	}

	public function redraw():Void {

		if (_ready == 1) {
 			_slider.content.x = (_position / _sound_player.length()) * _width;
		}

		// sness - Not sure why I have to subtract 1 here
 		_loaded_indicator.width = (_loaded * _width / _sound_player.length()) - 1;

		// Redraw the reticles
		_reticle.redraw();

	}

	public function showSlider():Void {
		if (_ready == 1) {
			_slider.content.visible = true;
		}
	}

	public function showBarSlider():Void {
		if (_ready == 1) {
			_slider.content.visible = false;
		}
	}
	

	// Set left and right edges of the i'th reticule.  The units are
	// SoundPlayer units
	public function setReticle(l_:Float, r_:Float) {

		var l:Float = (l_ / SoundPlayer.static_length()) * _width;
		var r:Float = (r_ / SoundPlayer.static_length()) * _width;

		var rx:Int;
		var ry:Int;
		var rheight:Int;
		var rwidth:Int;

		ry = 5;
		rheight = 30;

		rx = Std.int(l);
		rwidth = Std.int(r - l);
		
   		// trace(" l=" + l + " r=" + r + " rx=" + rx + " ry=" + ry + " rwidth=" + rwidth + " rheight=" + rheight );

		_reticle.setBox(rx,ry,rwidth,rheight);

		
	}

	//
	// Getters and setters
	//

	public function getPosition():Int {
		return Std.int(_position);
	}

	public function setPosition(i:Int):Void {
		_position = i;
	}

}

------------------------------ OrcaAnnotator.hx ------------------------------

//
// Test the integration of PaneWindows, MenuBars, ControlBars and
// AnalysisPopupWindows.
//

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.ProgressEvent;
import flash.events.IOErrorEvent;
import flash.media.Sound;
import flash.media.SoundChannel;
import flash.net.URLRequest;
import flash.external.ExternalInterface;

class OrcaAnnotator
{

	static var _well : Sprite;
	static var _controlbar : ControlBar;
	static var _annotator : Annotator;

	static var _sound_player : SoundPlayer;
	static var _volume_slider : VolumeSlider;
 	static var _time_indicator : TimeIndicator;
	static var _progress_bar : ProgressBar;
	static var _xml_loader : XMLLoader;

	// sness - Shouldn't this be part of SoundPlayer, or perhaps GlobalSettings?
	static var _sound_state : Int; // Are we currently playing the sound?

	static var _sound_position : Int; // The current playback position (0 - length_of_song in milliseconds)
	static var _sound_loaded : Int; // The amount of data that has been loaded (0 - length_of_song in milliseconds)

	// sness - Shouldn't this be part of ProgressBar, or perhaps GlobalSettings?
	static var _progress_bar_down : Bool; // Is the mouse down in the progress_bar?

	static var _r : OrcaAnnotator;

	static var _index : Int = 0;

	static var _current_time : Int = 0;

	static var _use_external_interface : Bool;

	function new(root) {
	}

	public static var _recording_url : String; // The path to Recording assets
	public static var _annotation_url : String; // The path to Annotation assets
	public static var _prediction_url : String; // The path to Prediction assets
	public static var _visualization_url : String; // The path to Visualization assets

	static function main ()
	{
		GlobalSettings.setDefaults();

		// Figure out the prefix of the filename we are looking at
		if (flash.Lib.current.loaderInfo.parameters.recording_url != null) {
			_recording_url = flash.Lib.current.loaderInfo.parameters.recording_url;
			_annotation_url = flash.Lib.current.loaderInfo.parameters.annotation_url;
			_prediction_url = flash.Lib.current.loaderInfo.parameters.prediction_url;
			_visualization_url = flash.Lib.current.loaderInfo.parameters.visualization_url;
			// sness - Hack for now, since at the start we don't know the audio length
			// until we've loaded it, but we need to know it to set the start and
			// end of the Prediction rectangles
			GlobalSettings.setAudioLength(2878920.0);
			_use_external_interface = true;
		} else {
			// If is undefined, we are in the standalone player, so just choose
			// a favorite file for debugging.
			_recording_url = "/assets/recordings/2005/449A";
  			_annotation_url = "/web/annotations/show/2.txt";
 			_prediction_url = "/web/predictions/show/2.txt";
 			//_visualization_url = "/assets/visualizations/2005/449A/spectrogram";
			_visualization_url = "/assets/visualizations/2005/449A/waveform";
			GlobalSettings.setAudioLength(2878920.0);
			_use_external_interface = false;
		}

		// Setup the main Timer object 
		var t = new haxe.Timer(5);
		t.run = onTimer;

		// Listen to events on the stage
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mainMouseDown);
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mainMouseUp);
		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDown);
		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUp);

		// Load the configuration file
		_xml_loader = new XMLLoader();
		flash.Lib.current.addChild(_xml_loader);

		// The SoundPlayer that loads and plays the MP3 file
		_sound_player = new SoundPlayer();
		_sound_state = 0;
		_sound_position = 0;
		_sound_loaded = 0;

		// Create a well to hold everything
		_well = new Sprite();
		_well.name = "main._well";

		// The control bar
   		_controlbar = new ControlBar(500,5,1000,30);
//   		_controlbar = new ControlBar(0,5,1000,30);
 		_well.addChild(_controlbar);

		// Listen for control bar events
		_controlbar.addEventListener(ControlBar.REWINDSTART_EVENT,rewindstartEventListener);
		_controlbar.addEventListener(ControlBar.REWIND_EVENT,rewindEventListener);
		_controlbar.addEventListener(ControlBar.PLAYPAUSE_EVENT,playpauseEventListener);
		_controlbar.addEventListener(ControlBar.FFWD_EVENT,ffwdEventListener);
		_controlbar.addEventListener(ControlBar.FFWDEND_EVENT,ffwdendEventListener);

		// The annotator
//  		var ann_x:Int = 200;
 		var ann_x:Int = 0;
		var ann_y:Int = 30;
		var ann_width:Int = 800;
		var ann_height:Int = 150;
		_annotator = new Annotator(ann_x,ann_y,ann_width,ann_height,_visualization_url,_sound_player);
 		_well.addChild(_annotator);

		// The progress bar
//    		_progress_bar = new ProgressBar(200,180,600,40,_sound_player);
		_progress_bar = new ProgressBar(0,200,600,40,_sound_player);
   		_well.addChild(_progress_bar);

		// Listen for progress bar events
		_progress_bar.addEventListener(ProgressBar.NEWPOSITION_EVENT,newPositionListener);

   		// The volume slider
//    		_volume_slider = new VolumeSlider(840,200,100,20);
		_volume_slider = new VolumeSlider(670,220,100,20);
  		_well.addChild(_volume_slider);

  		// The time indicator
//    		_time_indicator = new TimeIndicator(860,180,100,20);
		_time_indicator = new TimeIndicator(670,200,100,20);
  		_well.addChild(_time_indicator);

		flash.Lib.current.addChild(_well);

		if (_use_external_interface) {
			ExternalInterface.addCallback("visualizationChange", visualizationChange);
			ExternalInterface.addCallback("followModeChange", followModeChange);
		}

	}

	private static function newPositionListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = _progress_bar.getPosition();
		playSound();
	}
 
	private static function rewindstartEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = 0;
		playSound();
	}

	private static function rewindEventListener(e:Event):Void {
		_sound_player.stop();
		// sness - Is 30000 a good number to rewind by?
		_sound_position -= 30000;
		playSound();
	}

	private static function playpauseEventListener(e:Event):Void {
		if (_sound_state == 1) {
  			stopSound();
		} else {
  			playSound();
		}
	}

	private static function ffwdEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position += 30000;
		playSound();
	}

	static private function ffwdendEventListener(e:Event):Void {
		_sound_player.stop();
		_sound_position = _sound_player.length();
		playSound();
	}

	static private function mainMouseDown(e:Event):Void {
	}

	static private function mainMouseUp(e:Event):Void {
	}

 	public static function playSound():Void {
		_sound_player.play(_sound_position);
		_sound_state = 1;
	}

	public static function stopSound():Void {
		_sound_player.stop();
		_sound_state = 0;
	}

	static private function mainKeyDown(e:KeyboardEvent):Void {
		if (e.keyCode == 83) {
			_annotator.saveAnnotations();
		}
	}


	static private function mainKeyUp(e:KeyboardEvent):Void {
	}


	private static function redraw ():Void {
	}

	/***********************************************************************/
	/*  The main coordinating function that looks at the status of all the */
	/*  objects and updates the other objects based on the current state.  */
	/***********************************************************************/
	static function onTimer() {
		// Current position in the song
		if (_sound_state == 1) {
			_sound_position = _sound_player.getPosition();
		}
		_sound_loaded = _sound_player.getLoaded();

 		// Volume
 		if (_sound_state == 1) {
 			_sound_player.setVolume(_volume_slider.getValue());
 		}

 		// Time indicator
 		_time_indicator.value = _sound_position;
 		if (_progress_bar._mouse_down) {
 			_time_indicator.value = _progress_bar.getPosition();
 		}
 		_time_indicator.redraw();

 		// Progress bar
		if (!_progress_bar._mouse_down) {
			_progress_bar.setPosition(_sound_position);
		}
 		_progress_bar._loaded = _sound_loaded;
		_progress_bar.redraw();

		if (_sound_position > _sound_player.length()) {
			stopSound();
			_sound_position = 0;
		}

		// Update the ProgressBar reticules based on the x position of each of
		// the LayerViews.
		//
		// sness - This seems to me to be inefficient.  Could we instead do this
		// when the view in the Annotator changes?
  		_progress_bar.setReticle(_annotator.get_start_ms(),_annotator.get_end_ms());

		// Update the position of the annotator for the different kinds of
		// follow playback modes
		_annotator.redraw();


// 		// Every 1000 ticks, check to see if we need to save the annotations
// 		if (_current_time % 1000 == 0) {
// 			if (_annotator.getSaved() == false) {
// 				_annotator.saveAnnotations();
// 			}
// 		}

		_current_time += 1;
	}


	//////////////////////////////////////////////////////////////////////////////////
	//
	// Javascript callback functions
	//
	//////////////////////////////////////////////////////////////////////////////////

	// sness - Remember to add an ExternalInterface.addCallback() to the main loop 
	// for all new functions you add here

	static public function visualizationChange(s:String):Void {
		_visualization_url = s;
		_annotator.reloadVisualization();
	}

	static public function followModeChange(s:String):Void {
		GlobalSettings.setFollowMode(Std.parseInt(s));
	}




}


------------------------------ Annotator.hx ------------------------------

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;
	var _image_container:Sprite;
	var _prediction_container:Sprite;
	var _playback_bar:Sprite;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;

	var _height : Float;
	var _width  : Float;

	var _mouse_down : Bool;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The array of all predictions in this Annotator
	var _prediction_array : Array<Prediction>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;
	var _prediction_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;
	var _max_zoom:Int;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	// _zoom_ms_scale_factor puts all these together into a single number that you
	// can multiply ms by to get pixels
	var _zoom_ms_scale_factor:Float; 
	var _zoom_pix_scale_factor:Float; 

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	private var _sound_player : SoundPlayer;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;
		_sound_player = sound_player_;

		_annotation_array = [];
		_prediction_array = [];

		_mouse_down = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.
 		_zoom = 0.0;
 		_zoom_increment = 0.1;
		setZoom(_zoom);

		// sness - Just setting these to known values for now, should change
		// this to get the values from GlobalSettings.
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

		// The center line for the Annotator
		_playback_bar = new Sprite();
		_playback_bar.graphics.lineStyle(1,0x333333);		
		_playback_bar.graphics.moveTo(0,0);
		_playback_bar.graphics.lineTo(2,0);
		_playback_bar.graphics.lineTo(2,_height);
		_playback_bar.graphics.lineTo(0,_height);
		_playback_bar.graphics.lineTo(0,0);
		_playback_bar.x = _width / 2;
		this.addChild(_playback_bar);

		// A container for all the annotations we will load
		_image_container = new Sprite();
		_well.addChild(_image_container);

		// A container for all the predictions we will load
		_prediction_container = new Sprite();
		_well.addChild(_prediction_container);

		// sness - This is needed so that we can detect when the user releases the mouse
		// button when they are outside the window, otherwise, if they are dragging the mouse
		// and then release the mouse outside, the window continues to scroll.
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
   		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		_image_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		_image_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_image_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
   		_image_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_prediction_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_prediction_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_prediction_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_prediction_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDownListener);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUpListener);


		// The grey dragger that allows the user to create new annotations
		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);

 		// Get the text file for the predictions
		var url:String = OrcaAnnotator._prediction_url;
		_prediction_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_prediction_textfile_loader.load(request);
		_prediction_textfile_loader.addEventListener(Event.COMPLETE, predictionTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();

	}

	////////////////////////////////////////
	//
	// Listeners
	//
	////////////////////////////////////////

	private function loadImageListener(e:Event):Void {
 		var l:Loader = e.target.loader;
  		_image_container.addChildAt(l.content,0);
 		l.content.visible = true;
 		l.content.x = Std.parseInt(l.name);
		_total_loaded += 1;
		_loaded = true;
		setZoom(_zoom);
 	}


 	function mouseWheelListener(e:MouseEvent):Void {
		if (e.delta < 0) {
 			_zoom -= _zoom_increment / (_zoom + 1) ;
		} else {
 			_zoom += _zoom_increment / (_zoom + 1);
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 5.9) {
 			_zoom = 5.9;
 		}
		setZoom(_zoom);
	}

 	function mouseDownListener(e:MouseEvent):Void {
//   		trace("down");
		// sness - I needed the following at some time, but don't need it now...
// 		if (e.eventPhase != EventPhase.AT_TARGET) {
// 			trace("returning");
// 			return;
// 		}

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_mouse_down = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

// 		trace("dragging");
		// Allow the user to drag the Annotator
		_well.startDrag(false,_trackRect);


 	}

 	function mouseUpListener(e:MouseEvent):Void {
		_mouse_down = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener(e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - _well.x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		if (_mouse_down == true) {
			_dragger_start = e.stageX - _well.x;
			redraw();
		}
		calcEdges();
		loadNecessaryImages();
	}

	private function mainKeyDownListener(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		if (_dragger_visible) {
			// Check to see if we need to swap _dragger_start and _dragger_end
			if (_dragger_start > _dragger_end) {
				var tmp:Float = _dragger_end;
				_dragger_end = _dragger_start;
				_dragger_start = tmp;
			}

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	private function mainKeyUpListener(e:KeyboardEvent):Void {
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}


	////////////////////////////////////////
	//
	// File load completion handlers
	//
	////////////////////////////////////////

	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {
		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoom_level = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
 				if (zoom_level != null && index != null) {
 					_image_urls[zoom_level][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}
		_images_ready = true;

		loadNecessaryImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	private function predictionTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _prediction_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
  				var confidence = Std.parseFloat(elements[4]);
  				var color = Std.parseInt(elements[5]);
				if (id != null && start_ms != null && end_ms != null && name != null && color != null) { 
					createPrediction(id,start_ms,end_ms,name,confidence,color);
				}
			}
		}
	}

	public function calcEdges():Void {
		if (_well != null) {
			_view_start_ms = (_orig_x - _well.x) * _zoom_pix_scale_factor;
			_view_end_ms = _view_start_ms + (800 * _zoom_pix_scale_factor);
			_view_center_ms = _view_start_ms + ((_view_start_ms + _view_end_ms) / 2);
		}
	}

	public function loadNecessaryImages():Void {
		if (_images_ready) {
			var zoom_level:Int = Std.int(_zoom);
			if (zoom_level > GlobalSettings.getMaxZoom()) {
				zoom_level = GlobalSettings.getMaxZoom();
			}

			// How many different images are at this zoom level
			var sections:Float = Math.pow(3,zoom_level);
			var audio_length:Float = GlobalSettings.getAudioLength();
			var section_size:Float = audio_length / sections;
		
			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = section_size;
			for (i in 0..._image_urls[zoom_level].length) {
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms))) {
					if (_images[zoom_level][i] == null) {
						loadImage(zoom_level,i);
					}
				}
				start = end;
				end += section_size;
			}

		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
//   		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
//  		trace("_image_urls[zoom_level][index]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();
		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, loadImageListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));
	}


	public function setZoom(zoom:Float) {

		calcEdges();
		var old_view_center_ms:Float = _view_center_ms;

		// The zoom level, an int between 0 and 5
		var zoom_level:Int = Std.int(zoom);
		if (zoom_level > GlobalSettings.getMaxZoom()) {
			zoom_level = GlobalSettings.getMaxZoom();
		}

		// Just the fractional part of zoom_level
		var zoom_mod:Float = (zoom - zoom_level);

		// The actual amount we are zooming the images by
		var zoom_value:Float = (zoom_mod * 0.666) + 0.333;

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();
		
		// How many different images are at this zoom level
		var sections:Float = Math.pow(3,zoom_level);

		// _zoom_ms_scale_factor puts all these together into a single number
		// that you can multiply ms by to get pixels
		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// _zoom_pix_scale_factor puts all these together into a single number
		// that you can multiply pixels by to get ms
		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * zoom_value);

		// Calculate the positions of the start and edges that are currently visible
		loadNecessaryImages();
		calcEdges();

		// Recenter the view on the old center
		
		// sness - This is just about there, but misses zooming in on the center
		// by about 200 pixels too far to the left.  Very strange.  One data
		// point is that the left edge of the Annotator window is at the zoom in
		// point.  Something tricky needs to be done.
		if (!Math.isNaN(old_view_center_ms)) {
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((old_view_center_ms - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
// 			trace("old_view_center_ms=" + old_view_center_ms + " _view_center_ms=" + _view_center_ms + "_well.x=" + _well.x);
		}

		// Hide all the images
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
				if (_images[zoom_level][j] != null && _images[zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * zoom_value);
					_images[zoom_level][j].content.visible = true;
					_images[zoom_level][j].content.scaleX = zoom_value;
					_images[zoom_level][j].content.x = shift_x;
// 					trace("zoom_level= " + zoom_level + " j= " + j);
				}
 			}
 		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}

		// Get each prediction to update it's start and end ends
		for (n in _prediction_array) {
			n.redraw();
		}
	}

 	public function redraw() {

		//
		// If we are in (followMode == (page == 0))
		//
		// - Find what the current position of the playback bar should be
		// - If the playback bar isn't visible, adjust the window so that
		// the playback bar is at the far left edge of the window.
		// - Move the playback bar to the current sound position
		// 
 		if (GlobalSettings.getFollowMode() == 0) {
			var pos:Float = _sound_player.getPosition();
			if (pos < _view_start_ms || pos > _view_end_ms) {
				// Find the new x position of the frame based on this new view center
				_well.x = (_zoom_pix_scale_factor * _orig_x - pos) / _zoom_pix_scale_factor;
			}
			_playback_bar.x = ms2pix(pos - _view_start_ms);
			calcEdges();
			loadNecessaryImages();
		}

		//
		// If we are in (followMode == (scroll == 1))
		//
		// Move the center of the view to be centered on that position
 		if (GlobalSettings.getFollowMode() == 1) {
			// Move the playback_bar to the center of the view
			_playback_bar.x = _width / 2;
			// Find the current song position, which will be the new view center
			var pos:Int = _sound_player.getPosition();
			// Find the new x position of the frame based on this new view center
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((pos - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
			calcEdges();
			loadNecessaryImages();
 		}

		//
		// If we are in (followMode == (off == 2))
		//
		// Move the playback bar to the current sound position
 		if (GlobalSettings.getFollowMode() == 2) {
			_playback_bar.x = ms2pix(_sound_player.getPosition());
 		}

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}
 	}


	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		return ms * _zoom_ms_scale_factor;
	}

	// Create a new annotation
	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
	}

	// Create a new prediction
	function createPrediction(id:Int,start_ms:Float,end_ms:Float,title:String,confidence:Float,color:Int) {
 		var prediction = new Prediction(id,start_ms,end_ms,title,confidence,color,this);
 		var i:Int = _prediction_array.push(prediction);
 		prediction._index = i;
 		_prediction_container.addChild(prediction);
	}

	// Redraw all the annotations in _annotation_array
	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-1000000.0, 0, _width + 1000000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

	// The rectangular playback bar
	public function setPlaybackBar(f:Float):Void {
		_playback_bar_ms = f;
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	// Called when the web server returns a response to us trying to save the
	// annotations.  The web server should return the string "update complete "
	// if everything worked.
	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}
		_saved = true;
	}
	
	// Have all the annotations been saved back to the web server?
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	// Load a specific visualization from the web server, for
	// example, the waveform or spectrogram view
	public function loadVisualization() {
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
 		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);
	}

	// Called from the main OrcaAnnotator class by Javascript when the 
	// user requests to see a different visualization
	public function reloadVisualization() {
		for(i in 0..._image_container.numChildren) {
			_image_container.removeChildAt(0);
		}

		_images = new Array();
		_image_urls = new Array();
		loadVisualization();
	}

	// Return the leftmost position of the currently visible window
	// in sound position units
	public function get_start_ms():Float {
		calcEdges();
		return _view_start_ms;
	}

	// Return the rightmost position of the currently visible window
	// in sound position units
	public function get_end_ms():Float {
		return _view_end_ms;
	}

}


------------------------------ Annotator.hx ------------------------------

** Mon Jul 13 2009 - 16:49:55 PM
   -----------------------------

The old redraw:

 	public function redraw() {

		trace("_well.x=" + _well.x);
  		trace("s=" + _view_start_ms + " c=" + _view_center_ms + " e=" + _view_end_ms);

		//
		// If we are in (followMode == (page == 0))
		//
		// - Find what the current position of the playback bar should be
		// - If the playback bar isn't visible, adjust the window so that
		// the playback bar is at the far left edge of the window.
		// - Move the playback bar to the current sound position
		// 
 		if (GlobalSettings.getFollowMode() == 0) {
			var pos:Float = OrcaAnnotator.getPosition();
			if (pos < _view_start_ms || pos > _view_end_ms) {
				// Find the new x position of the frame based on this new view center
				_well.x = (_zoom_pix_scale_factor * _orig_x - pos) / _zoom_pix_scale_factor;
			}
			_playback_bar.x = ms2pix(pos - _view_start_ms);
			calcEdges();
			loadNecessaryImages();
		}

		//
		// If we are in (followMode == (scroll == 1))
		//
		// Move the center of the view to be centered on that position
 		if (GlobalSettings.getFollowMode() == 1) {
			// Move the playback_bar to the center of the view
			_playback_bar.x = _width / 2;
			// Find the current song position, which will be the new view center
			var pos:Int = OrcaAnnotator.getPosition();
			// Find the new x position of the frame based on this new view center
			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
					   ((pos - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
			calcEdges();
			loadNecessaryImages();
 		}

		//
		// If we are in (followMode == (off == 2))
		//
		// Move the playback bar to the current sound position
 		if (GlobalSettings.getFollowMode() == 2) {
			_playback_bar.x = ms2pix(OrcaAnnotator.getPosition());
 		}

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}
 	}


------------------------------ Annotator.hx ------------------------------

  		//trace("e.localX=" + e.localX + " s=" + Std.int(_view_start_ms) + " c=" + Std.int(_view_center_ms) + " e=" + Std.int(_view_end_ms) + " pos=" + Std.int(pos) + " mspos=" + mspos);

// 		trace("_playback_bar.x=" + _playback_bar.x + " e.stageX=" + e.stageX + " _well.x=" + _well.x + " s=" + Std.int(_view_start_ms) + " c=" + Std.int(_view_center_ms) + " e=" + Std.int(_view_end_ms) + " pos=" + pos + " mspos=" + mspos);



// 		var start:Float = _dragger_start;
// 		var end:Float = _dragger_end;
		trace("s=" + Std.int(_view_start_ms) + " e=" + Std.int(_view_end_ms) + " ds=" + Std.int(start) + " de=" + Std.int(end) + " z" + _zoom + " zms=" + _zoom_ms_scale_factor);


------------------------------ Annotator.hx ------------------------------

		var o:Float = audio_length / (_zoom_pix_scale_factor * 2400.0);
		var v:Int;
		if (o < 1) {
			v = 1;
		} else {
			v = Std.int(Math.pow(3,Std.int(Math.log(o) / Math.log(3.0))+1));
		}


------------------------------ Annotator.hx ------------------------------ 

// 		trace("scale=" + scale + " o=" + r(o) + " zl=" + zoom_level + " sec=" + sections + " zv=" + zoom_value + " zf=" + zoom_frac + " zoom=" + _zoom);
// 		trace("s=" + Std.int(_view_start_ms) + " e=" + Std.int(_view_end_ms) + " ds=" + Std.int(start_ms) + " de=" + Std.int(end_ms) + " z" + _zoom + " zms=" + _zoom_ms_scale_factor);
//  		trace("s=" + start_ms + " e=" + end_ms + " s=" + _zoom_pix_scale_factor + " scale=" + scale);


// 		trace("s=" + r(_view_start_ms) + " e=" + r(_view_end_ms) + " z=" + r(_zoom) + " zms=" + r(_zoom_ms_scale_factor) + " zps=" + r(_zoom_pix_scale_factor) + " o=" + r(audio_length / (_zoom_pix_scale_factor * 2400.0)) + " sec=" + sections + " zv=" + r(zoom_value));


------------------------------ Annotator.hx ------------------------------

		// sness - This is just about there, but misses zooming in on the center
		// by about 200 pixels too far to the left.  Very strange.  One data
		// point is that the left edge of the Annotator window is at the zoom in
		// point.  Something tricky needs to be done.
// 		if (!Math.isNaN(old_view_center_ms)) {
// 			_well.x = ((_zoom_pix_scale_factor * _orig_x) - 
// 					   ((old_view_center_ms - 400 * _zoom_pix_scale_factor)/2.0) / _zoom_pix_scale_factor);
// 			trace("old_view_center_ms=" + old_view_center_ms + " _view_center_ms=" + _view_center_ms + "_well.x=" + _well.x);
// 		}

		
------------------------------ Annotator.hx ------------------------------

** Mon Jul 20 2009 - 11:13:00 AM
   -----------------------------

Before embarking on the refactoring to move the window edge
calculations to their own function

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;
	var _image_container:Sprite;
	var _prediction_container:Sprite;
	var _playback_bar:Sprite;
// 	var _center_bar:Sprite;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;

	var _height : Float;
	var _width  : Float;

	var _moving_dragger : Bool;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The array of all predictions in this Annotator
	var _prediction_array : Array<Prediction>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;
	var _prediction_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;
	var _max_zoom:Int;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	var _zoom_ms_scale_factor:Float;  // number that you can multiply ms by to get pixels
	var _zoom_pix_scale_factor:Float; //  number that you can multiply pixels by to get ms

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	private var _sound_player : SoundPlayer;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;
		_sound_player = sound_player_;

		_annotation_array = [];
		_prediction_array = [];

		_moving_dragger = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.
		_zoom = 0.0;
 		_zoom_increment = 0.1;
		doZoom();

		// sness - Just setting these to known values for now, should change
		// this to get the values from GlobalSettings.
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

 		// The current playback position
 		_playback_bar = new Sprite();
 		_playback_bar.graphics.lineStyle(1,0x333333);		
 		_playback_bar.graphics.moveTo(0,0);
 		_playback_bar.graphics.lineTo(2,0);
 		_playback_bar.graphics.lineTo(2,_height);
 		_playback_bar.graphics.lineTo(0,_height);
 		_playback_bar.graphics.lineTo(0,0);
 		_playback_bar.x = _width / 2;
 		this.addChild(_playback_bar);

// 		// The center of the Annotator
// 		_center_bar = new Sprite();
// 		_center_bar.graphics.lineStyle(1,0x000000);		
// 		_center_bar.graphics.beginFill(0x000000,1);
// 		var triangle_size:Float = 2;
// 		// Top triangle
// 		_center_bar.graphics.moveTo((_width/2)-triangle_size,0);
// 		_center_bar.graphics.lineTo((_width/2)+triangle_size,0);
// 		_center_bar.graphics.lineTo((_width/2)+0.5,triangle_size);
// 		// Vertical line
//  		_center_bar.graphics.moveTo(_width/2,0);
//  		_center_bar.graphics.lineTo((_width/2),_height);
// 		// Bottom triangle
// 		_center_bar.graphics.moveTo((_width/2)-triangle_size,_height);
// 		_center_bar.graphics.lineTo((_width/2)+triangle_size,_height);
// 		_center_bar.graphics.lineTo((_width/2)+0.5,_height-triangle_size);
// 		this.addChild(_center_bar);

		// A container for all the annotations we will load
		_image_container = new Sprite();
		_well.addChild(_image_container);

		// A container for all the predictions we will load
		_prediction_container = new Sprite();
		_well.addChild(_prediction_container);

		// sness - This is needed so that we can detect when the user releases the mouse
		// button when they are outside the window, otherwise, if they are dragging the mouse
		// and then release the mouse outside, the window continues to scroll.
// 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
// 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
//    		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		_image_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		_image_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_image_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
   		_image_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_prediction_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_prediction_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_prediction_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_prediction_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDownListener);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUpListener);


		// The grey dragger that allows the user to create new annotations
		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);

 		// Get the text file for the predictions
		var url:String = OrcaAnnotator._prediction_url;
		_prediction_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_prediction_textfile_loader.load(request);
		_prediction_textfile_loader.addEventListener(Event.COMPLETE, predictionTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();

	}

	////////////////////////////////////////
	//
	// Listeners
	//
	////////////////////////////////////////

	// Zoom in and out when the user scrolls the mouse wheel
 	function mouseWheelListener(e:MouseEvent):Void {
		if (e.delta < 0) {
 			_zoom -= _zoom_increment / (_zoom + 1) ;
		} else {
 			_zoom += _zoom_increment / (_zoom + 1);
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 4.9) {
 			_zoom = 4.9;
 		}
		doZoom();
	}

 	function mouseDownListener(e:MouseEvent):Void {
		//trace("down");
// 		if (_well != null) {
// 			trace("_well.x=" + _well.x);
// 		}

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_moving_dragger = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Find the position of the mouse in ms and et the current playback
		// position to this point
		if (!e.shiftKey) {
			calcEdges();
			var pos:Float = e.stageX / _width;
			var mspos:Int = Std.int(_view_start_ms + ((_view_end_ms - _view_start_ms) * pos));
			OrcaAnnotator.setPosition(mspos);
			redraw();
		}
		
		// Allow the user to drag the Annotator
		_well.startDrag(false,_trackRect);
 	}

 	function mouseUpListener(e:MouseEvent):Void {
		_moving_dragger = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener(e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - _well.x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		if (_moving_dragger) {
			_dragger_start = e.stageX - _well.x;
			calcEdges();
			loadNecessaryImages();
			redraw();
		}
// 		calcEdges();
// 		loadNecessaryImages();
	}

	private function mainKeyDownListener(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		var key:Int = e.keyCode;
		if (_dragger_visible && key != 16 && key != 17 && key != 18 ) {
			// Check to see if we need to swap _dragger_start and _dragger_end
// 			if (_dragger_start > _dragger_end) {
// 				var tmp:Float = _dragger_end;
// 				_dragger_end = _dragger_start;
// 				_dragger_start = tmp;
// 			}
			fixDraggerEnds();

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	private function mainKeyUpListener(e:KeyboardEvent):Void {
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}


	////////////////////////////////////////
	//
	// File load completion handlers
	//
	////////////////////////////////////////

	private function loadImageListener(e:Event):Void {
 		var l:Loader = e.target.loader;
  		_image_container.addChildAt(l.content,0);
 		l.content.visible = true;
 		l.content.x = Std.parseInt(l.name);
		_total_loaded += 1;
		_loaded = true;
		doZoom();
 	}

	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {
		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoom_level = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
 				if (zoom_level != null && index != null) {
 					_image_urls[zoom_level][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
 		}
		_images_ready = true;

		loadNecessaryImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	private function predictionTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _prediction_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
  				var confidence = Std.parseFloat(elements[4]);
  				var color = Std.parseInt(elements[5]);
				if (id != null && start_ms != null && end_ms != null && name != null && color != null) { 
					createPrediction(id,start_ms,end_ms,name,confidence,color);
				}
			}
		}
	}

	public function calcEdges():Void {
		if (_well != null) {
			_view_start_ms = (_orig_x - _well.x) * _zoom_pix_scale_factor;
			_view_end_ms = _view_start_ms + (_width * _zoom_pix_scale_factor);
			_view_center_ms = _view_start_ms + ((_view_end_ms - _view_start_ms) / 2);
		}
//  		trace("s=" + _view_start_ms + " c=" + _view_center_ms + " e=" + _view_end_ms);
	}

	public function loadNecessaryImages():Void {
		if (_images_ready) {
			var zoom_level:Int = Std.int(_zoom);
			if (zoom_level > GlobalSettings.getMaxZoom()) {
				zoom_level = GlobalSettings.getMaxZoom();
			}

			// How many different images are at this zoom level
			var sections:Float = Math.pow(3,zoom_level);
			var audio_length:Float = GlobalSettings.getAudioLength();
			var section_size:Float = audio_length / sections;
		
			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = section_size;
			for (i in 0..._image_urls[zoom_level].length) {
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms))) {
					if (_images[zoom_level][i] == null) {
						loadImage(zoom_level,i);
					}
				}
				start = end;
				end += section_size;
			}
		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
//    		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
//   		trace("_image_urls[zoom_level][index]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();
		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, loadImageListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));
	}


	public function doZoom():Void {
// 		calcEdges();
		var old_view_center_ms:Float = _view_center_ms;

		// The zoom level, an int between 0 and 5
		var zoom_level:Int = Std.int(_zoom);
		if (zoom_level > GlobalSettings.getMaxZoom()) {
			zoom_level = GlobalSettings.getMaxZoom();
		}

		// Just the fractional part of zoom_level
		var zoom_frac:Float = (_zoom - zoom_level);

		// The actual amount we are zooming the images by
		var zoom_value:Float = (zoom_frac * 0.666) + 0.333;

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();
		
		// How many different images are at this zoom level
		var sections:Float = Math.pow(3,zoom_level);

		// _zoom_ms_scale_factor puts all these together into a single number
		// that you can multiply ms by to get pixels
		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// _zoom_pix_scale_factor puts all these together into a single number
		// that you can multiply pixels by to get ms
		_zoom_pix_scale_factor = audio_length / (sections * 2400.0 * zoom_value);

		// Calculate the positions of the start and edges that are currently visible
		loadNecessaryImages();
		calcEdges();

		//
		// Center the view on the current playback position
		//
		var bar:Float = getPlaybackBar();

		_view_center_ms = bar;
		


		// Hide all the images
 		if (_loaded) {
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}
		}

		// Just show the images in the current zoom_level
 		if (_loaded) {
 			for (j in 0..._images[zoom_level].length) {
				if (_images[zoom_level][j] != null && _images[zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * zoom_value);
					_images[zoom_level][j].content.visible = true;
					_images[zoom_level][j].content.scaleX = zoom_value;
					_images[zoom_level][j].content.x = shift_x;
// 					trace("zoom_level= " + zoom_level + " j= " + j);
				}
 			}
 		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}

		// Get each prediction to update it's start and end ends
		for (n in _prediction_array) {
			n.redraw();
		}
	}

 	public function redraw():Void {

// 		trace("redraw()");
// 		trace("_well.x=" + _well.x);
//   		trace("s=" + Std.int(_view_start_ms) + " c=" + Std.int(_view_center_ms) + " e=" + Std.int(_view_end_ms));

		// sness - In here we should recenter the view based on the current
		// playback slider position as obtained from OrcaAnnotator.getPosition()

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}

		setPlaybackBar(OrcaAnnotator.getPosition());
// 		_playback_bar.x = ms2pix(OrcaAnnotator.getPosition()) + _well.x;
 	}


	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		return ms * _zoom_ms_scale_factor;
	}

	public function newAnnotation() {
		fixDraggerEnds();
		createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
	}

	// Create a new annotation
	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
	}

	// Create a new prediction
	function createPrediction(id:Int,start_ms:Float,end_ms:Float,title:String,confidence:Float,color:Int) {
 		var prediction = new Prediction(id,start_ms,end_ms,title,confidence,color,this);
 		var i:Int = _prediction_array.push(prediction);
 		prediction._index = i;
 		_prediction_container.addChild(prediction);
	}

	// Redraw all the annotations in _annotation_array
	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-1000000.0, 0, _width + 1000000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}

	// The rectangular playback bar
	public function setPlaybackBar(f:Float):Void {
		_playback_bar_ms = f;
		_playback_bar.x = ms2pix(f) + _well.x;
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	// Called when the web server returns a response to us trying to save the
	// annotations.  The web server should return the string "update complete "
	// if everything worked.
	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}
		_saved = true;
	}
	
	// Have all the annotations been saved back to the web server?
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	// Load a specific visualization from the web server, for
	// example, the waveform or spectrogram view
	public function loadVisualization() {
		_images_ready = false;
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
 		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);
	}

	// Called from the main OrcaAnnotator class by Javascript when the 
	// user requests to see a different visualization
	public function reloadVisualization() {
		for(i in 0..._image_container.numChildren) {
			_image_container.removeChildAt(0);
		}

		_images = new Array();
		_image_urls = new Array();
		loadVisualization();
	}

	// Return the leftmost position of the currently visible window
	// in sound position units
	public function get_start_ms():Float {
		calcEdges();
		return _view_start_ms;
	}

	// Return the rightmost position of the currently visible window
	// in sound position units
	public function get_end_ms():Float {
		return _view_end_ms;
	}

 	public function zoomIn():Void {
		_zoom += (_zoom_increment * 10) / (_zoom + 1);
 		if (_zoom > 4.9) {
 			_zoom = 4.9;
 		}
		doZoom();
	}

 	public function zoomOut():Void {
		_zoom -= (_zoom_increment * 10) / (_zoom + 1) ;
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
		doZoom();
	}

 	public function zoomFull():Void {
		_zoom = 0.0;
		doZoom();
		_well.x = 0;
	}
	
	// Zoom to show the current selection
	//
	// sness - This is really difficult because we have to figure out what the
	// _zoom would be given ending points in ms.  Tricky parts include having to
	// take the log base 3 of a quantity halfway though.  Ouch.
 	public function zoomSelection():Void {
		// Figure out the start and end points of the dragger in ms
		fixDraggerEnds();
 		_view_start_ms = pix2ms(_dragger_start);
 		_view_end_ms = pix2ms(_dragger_end);
		_view_center_ms = (_view_start_ms + _view_end_ms) / 2;

		// Figure out what zoom level we would need to show those end points
		_zoom_pix_scale_factor = Math.abs((_view_start_ms - _view_end_ms) / _width);


		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();

		var o:Float = audio_length / (_zoom_pix_scale_factor * 2400.0);
		var sections:Int;
		var zoom_level:Int;
		if (o < 1) {
			zoom_level = 0;
			sections = 1;
		} else {
			zoom_level = Std.int(Math.log(o) / Math.log(3.0))+1;
			sections = Std.int(Math.pow(3,zoom_level));
		}
		
		var zoom_value:Float = audio_length / (_zoom_pix_scale_factor * sections * 2400);
		var zoom_frac:Float = (zoom_value - 0.3333) / 0.6666;
		_zoom = zoom_frac + zoom_level;

		_zoom_ms_scale_factor = zoom_value / (audio_length / (sections * 2400.0));

		// Figure out the x-offset
  		_well.x = -1.0 * ms2pix(_view_start_ms);

		doZoom();

		// Change the dragger coordinates to fill the screen
		_dragger_start = ms2pix(_view_start_ms);
 		_dragger_end = ms2pix(_view_end_ms);

 		redraw();
	}

	// A "r"easonable number of decimal points for trace()
	public function r(f:Float):Float {
		var d:Float = 10000;
		var n:Int = Std.int(f * d);
		return n / d;
	}

	public function tracer():Void {
		var audio_length:Float = GlobalSettings.getAudioLength();
// 		trace("wx=" + _well.x + " ds=" + _dragger_start + " de=" + _dragger_end);
// 		trace("vs=" + Std.int(_view_start_ms) + " ve=" + Std.int(_view_end_ms));
//  		trace("fvs=" + _view_start_ms / audio_length + " fve=" + _view_end_ms / audio_length);
// 		if (_well != null) {
// 			trace("wx=" + _well.x + " ds=" + r(_dragger_start) + " de=" + r(_dragger_end) + " fvs=" + r(_view_start_ms / audio_length) + " fve=" + r(_view_end_ms / audio_length));
// 		}
		trace("bar=" + r(getPlaybackBar() / audio_length));
	}

	// If the start of the dragger is bigger than the end, swap them
	public function fixDraggerEnds():Void {
// 		trace("b ds=" + _dragger_start + " de=" + _dragger_end);
		if (_dragger_start > _dragger_end) {
			var tmp:Float = _dragger_start;
			_dragger_start = _dragger_end;
			_dragger_end = tmp;
		}
// 		trace("a ds=" + _dragger_start + " de=" + _dragger_end);
	}

}


------------------------------ Annotator.hx ------------------------------

		// trace("s=" + _view_start_ms + " c=" + _view_center_ms + " e=" + _view_end_ms);


------------------------------ Annotator.hx ------------------------------

** Tue Jul 21 2009 - 13:24:09 PM
   -----------------------------

Getting lots of bugs fixed, at a good point:

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.ProgressEvent;
import flash.events.HTTPStatusEvent;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;
	var _image_container:Sprite;
	var _prediction_container:Sprite;
	var _playback_bar:Sprite;
	// 	var _center_bar:Sprite;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;

	var _height : Float;
	var _width  : Float;

	var _moving_dragger : Bool;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The array of all predictions in this Annotator
	var _prediction_array : Array<Prediction>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;
	var _prediction_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;
	var _zoom_level:Int;
	var _zoom_value:Float;
	var _sections:Float;
	var _audio_length:Float;
	var _section_size_ms:Float;

	var _max_zoom:Int;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
 	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	var _zoom_ms_scale_factor:Float;  // number that you can multiply ms by to get pixels
	var _zoom_pix_scale_factor:Float; //  number that you can multiply pixels by to get ms

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	private var _sound_player : SoundPlayer;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;
		_sound_player = sound_player_;

		_annotation_array = [];
		_prediction_array = [];

		_moving_dragger = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.
		_zoom = 0.0;
 		_zoom_increment = 0.1;
		doZoom();

		// sness - Just setting these to known values for now, should change
		// this to get the values from GlobalSettings.
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

 		// The current playback position
 		_playback_bar = new Sprite();
 		_playback_bar.graphics.lineStyle(1,0x333333);		
 		_playback_bar.graphics.moveTo(0,0);
 		_playback_bar.graphics.lineTo(2,0);
 		_playback_bar.graphics.lineTo(2,_height);
 		_playback_bar.graphics.lineTo(0,_height);
 		_playback_bar.graphics.lineTo(0,0);
 		_playback_bar.x = _width / 2;
 		this.addChild(_playback_bar);

		// 		// The center of the Annotator
		// 		_center_bar = new Sprite();
		// 		_center_bar.graphics.lineStyle(1,0x000000);		
		// 		_center_bar.graphics.beginFill(0x000000,1);
		// 		var triangle_size:Float = 2;
		// 		// Top triangle
		// 		_center_bar.graphics.moveTo((_width/2)-triangle_size,0);
		// 		_center_bar.graphics.lineTo((_width/2)+triangle_size,0);
		// 		_center_bar.graphics.lineTo((_width/2)+0.5,triangle_size);
		// 		// Vertical line
		//  		_center_bar.graphics.moveTo(_width/2,0);
		//  		_center_bar.graphics.lineTo((_width/2),_height);
		// 		// Bottom triangle
		// 		_center_bar.graphics.moveTo((_width/2)-triangle_size,_height);
		// 		_center_bar.graphics.lineTo((_width/2)+triangle_size,_height);
		// 		_center_bar.graphics.lineTo((_width/2)+0.5,_height-triangle_size);
		// 		this.addChild(_center_bar);

		// A container for all the annotations we will load
		_image_container = new Sprite();
		_well.addChild(_image_container);

		// A container for all the predictions we will load
		_prediction_container = new Sprite();
		_well.addChild(_prediction_container);

		// sness - This is needed so that we can detect when the user releases the mouse
		// button when they are outside the window, otherwise, if they are dragging the mouse
		// and then release the mouse outside, the window continues to scroll.
		// 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		// 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		_image_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		_image_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_image_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
   		_image_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_prediction_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_prediction_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_prediction_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_prediction_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDownListener);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUpListener);


		// The grey dragger that allows the user to create new annotations
		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);

 		// Get the text file for the predictions
		var url:String = OrcaAnnotator._prediction_url;
		_prediction_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_prediction_textfile_loader.load(request);
		_prediction_textfile_loader.addEventListener(Event.COMPLETE, predictionTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();

	}

	////////////////////////////////////////
	//
	// Listeners
	//
	////////////////////////////////////////

	// Zoom in and out when the user scrolls the mouse wheel
 	function mouseWheelListener(e:MouseEvent):Void {
		if (e.delta < 0) {
 			_zoom -= _zoom_increment / (_zoom + 1) ;
		} else {
 			_zoom += _zoom_increment / (_zoom + 1);
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 4.9) {
 			_zoom = 4.9;
 		}
		doZoom();
	}

 	function mouseDownListener(e:MouseEvent):Void {
		//trace("down");
		// 		if (_well != null) {
		// 			trace("_well.x=" + _well.x);
		// 		}

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_moving_dragger = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Find the position of the mouse in ms and et the current playback
		// position to this point
		//
		// sness - FIXME GETTER
		if (!e.shiftKey) {
			calcEdges();
			var pos:Float = e.stageX / _width;
			var mspos:Int = Std.int(_view_start_ms + ((_view_end_ms - _view_start_ms) * pos));
			OrcaAnnotator.setPosition(mspos,true);
			redraw();
		}
		
		// Allow the user to drag the Annotator
		_well.startDrag(false,_trackRect);
 	}

 	function mouseUpListener(e:MouseEvent):Void {
		_moving_dragger = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener(e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - _well.x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		//
		// sness - FIXME GETTER
		if (_moving_dragger) {
			_dragger_start = e.stageX - _well.x;
			calcEdges();
			loadNecessaryImages();
			redraw();
		}
		// 		calcEdges();
		// 		loadNecessaryImages();
	}

	private function mainKeyDownListener(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		var key:Int = e.keyCode;
		if (_dragger_visible && key != 16 && key != 17 && key != 18 ) {
			// Check to see if we need to swap _dragger_start and _dragger_end
			// 			if (_dragger_start > _dragger_end) {
			// 				var tmp:Float = _dragger_end;
			// 				_dragger_end = _dragger_start;
			// 				_dragger_start = tmp;
			// 			}
			fixDraggerEnds();

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	private function mainKeyUpListener(e:KeyboardEvent):Void {
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}


	////////////////////////////////////////
	//
	// File load completion handlers
	//
	////////////////////////////////////////

	private function loadImageListener(e:Event):Void {
// 		trace("e.target" + e.target + " e.target.loader=" + e.target.loader);
 		var l:Loader = e.target.loader;
//    		_image_container.addChildAt(l.content,0);
//  		l.content.visible = true;
 		l.content.x = Std.parseInt(l.name);
// 		trace("l.content.x=" + l.content.x);
		_total_loaded += 1;
		_loaded = true;
		// sness - We probably don't need to do this, not sure why it was here
		// 
		// sness - Ah... This is probably setting the scaleX property correctly
 		doZoom();
 	}

	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {
		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoomlevel = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
 				if (zoomlevel != null && index != null) {
 					_image_urls[zoomlevel][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
			var sections:Int = Std.int(Math.pow(3,i));
			for (j in 0...sections) {
				_images[i].push(null);
			}
 		}
		_images_ready = true;

		loadNecessaryImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	private function predictionTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _prediction_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
  				var confidence = Std.parseFloat(elements[4]);
  				var color = Std.parseInt(elements[5]);
				if (id != null && start_ms != null && end_ms != null && name != null && color != null) { 
					createPrediction(id,start_ms,end_ms,name,confidence,color);
				}
			}
		}
	}


	public function loadNecessaryImages():Void {
//   		trace("load");
		if (_images_ready) {

			// sness - FIXME GETTER
			calcEdges();
// 			// How many different images are at this zoom level
// 			var sections:Float = Math.pow(3,_zoom_level);
// 			var audio_length:Float = GlobalSettings.getAudioLength();
		
			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = _section_size_ms;

// 			trace("vs=" + _view_start_ms + " ve=" + _view_end_ms);

			for (i in 0..._image_urls[_zoom_level].length) {
//   				trace("iu[z]=" + _image_urls[_zoom_level][i] + " s=" + start + " e=" + end);
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms)) ||
					((start >= _view_start_ms) && (end >= _view_end_ms))) {
//  					trace("zl=" + _zoom_level + " i=" + i + " s=" + ii(start) + " vs=" + ii(_view_start_ms) + " e=" + ii(end) + " ve=" + ii(_view_end_ms));
					if (_images[_zoom_level][i] == null) {
						loadImage(_zoom_level,i);
					}
				}
				start = end;
				end += _section_size_ms;
			}
		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
// 		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
// 		trace("_image_urls[" + zoom_level + "][" + index + "]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();

   		_image_container.addChildAt(_images[zoom_level][index],0);

//  		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, loadImageListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));

		// sness - Debugging
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.OPEN, handleOpen);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, handleProgress);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.COMPLETE, handleComplete);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(HTTPStatusEvent.HTTP_STATUS, handleHttpStatus);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, handleIoError);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, handleSecurityError);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.UNLOAD, handleUnload);
	}

	private function handleOpen(e:Event):Void {
		trace("open");
	}

	private function handleProgress(e:Event):Void {
		trace("progress");
	}

	private function handleComplete(e:Event):Void {
		trace("complete");
	}

	private function handleHttpStatus(e:Event):Void {
		trace("httpstatus");
	}

	private function handleIoError(e:Event):Void {
		trace("ioerror");
	}

	private function handleSecurityError(e:Event):Void {
		trace("securityerror");
	}

	private function handleUnload(e:Event):Void {
		trace("unload");
	}




	public function doZoom():Void {
// 		trace("doZoom");
		// 		var old_view_center_ms:Float = _view_center_ms;

		setZoom(_zoom);

		// Calculate the positions of the start and edges that are currently visible
		loadNecessaryImages();
		// sness - FIXME GETTER
		// 		calcEdges();

		//
		// Center the view on the current playback position
		//
		setViewCenter_ms(getPlaybackBar());
		

// 		// Hide all the images
//  		if (_loaded) {
// 			for (i in 0..._images.length) {
// 				for (j in 0..._images[i].length) {
// 					if (_images[i][j] != null && _images[i][j].content != null) {
// 						_images[i][j].content.visible = false;
// 					}
// 				}
// 			}
// 		}

// 		// Just show the images in the current zoom_level
//  		if (_loaded) {
//  			for (j in 0..._images[_zoom_level].length) {
// 				if (_images[_zoom_level][j] != null && _images[_zoom_level][j].content != null) {
// 					var shift_x:Float = j * (2400 * _zoom_value);
// 					_images[_zoom_level][j].content.visible = true;
// 					_images[_zoom_level][j].content.scaleX = _zoom_value;
// 					_images[_zoom_level][j].content.x = shift_x;
// 					// 					trace("zoom_level= " + zoom_level + " j= " + j);
// 				}
//  			}
//  		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}

		// Get each prediction to update it's start and end ends
		for (n in _prediction_array) {
			n.redraw();
		}
	}

 	public function redraw():Void {

		// 		trace("redraw()");
		// 		trace("_well.x=" + _well.x);
		//   		trace("s=" + Std.int(_view_start_ms) + " c=" + Std.int(_view_center_ms) + " e=" + Std.int(_view_end_ms));

		// sness - In here we should recenter the view based on the current
		// playback slider position as obtained from OrcaAnnotator.getPosition()

		_dragger.graphics.clear();
		if (_dragger_visible) {
			_dragger.alpha = 0.5;
			_dragger.graphics.beginFill(0xCCCCCC,1);
			_dragger.graphics.moveTo(_dragger_start,0);
			_dragger.graphics.lineTo(_dragger_end,0);
			_dragger.graphics.lineTo(_dragger_end,_height);
			_dragger.graphics.lineTo(_dragger_start,_height);
			_dragger.graphics.lineTo(_dragger_start,0);
		}

		setPlaybackBar(OrcaAnnotator.getPosition());
		// 		_playback_bar.x = ms2pix(OrcaAnnotator.getPosition()) + _well.x;
		
		// sness - Not sure if this is necessary to do this on redraw, and
		// anyways should only do when dragging, when start/end has changed,
		// zoom has changed or center has changed.
// 		loadNecessaryImages();

 		if (_loaded && _images != null) {

			// Hide all the images
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}

			// Just show the images in the current zoom_level
 			for (j in 0..._images[_zoom_level].length) {
				if (_images[_zoom_level][j] != null && _images[_zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * _zoom_value);
					_images[_zoom_level][j].content.visible = true;
					_images[_zoom_level][j].content.scaleX = _zoom_value;
					_images[_zoom_level][j].content.x = shift_x;
					// 					trace("zoom_level= " + zoom_level + " j= " + j);
				}
 			}
 		}
		
 	}

	public function newAnnotation() {
		if (_dragger_visible) {
			fixDraggerEnds();
			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
		}
	}

	// Create a new annotation
	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
	}

	// Create a new prediction
	function createPrediction(id:Int,start_ms:Float,end_ms:Float,title:String,confidence:Float,color:Int) {
 		var prediction = new Prediction(id,start_ms,end_ms,title,confidence,color,this);
 		var i:Int = _prediction_array.push(prediction);
 		prediction._index = i;
 		_prediction_container.addChild(prediction);
	}

	// Redraw all the annotations in _annotation_array
	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-1000000.0, 0, _width + 1000000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	// Called when the web server returns a response to us trying to save the
	// annotations.  The web server should return the string "update complete "
	// if everything worked.
	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}
		_saved = true;
	}
	
	// Have all the annotations been saved back to the web server?
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	// Load a specific visualization from the web server, for
	// example, the waveform or spectrogram view
	public function loadVisualization() {
		_images_ready = false;
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
 		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);
	}

	// Called from the main OrcaAnnotator class by Javascript when the 
	// user requests to see a different visualization
	public function reloadVisualization() {
		for(i in 0..._image_container.numChildren) {
			_image_container.removeChildAt(0);
		}

		_images = new Array();
		_image_urls = new Array();
		loadVisualization();
	}

 	public function zoomIn():Void {
		_zoom += (_zoom_increment * 10) / (_zoom + 1);
 		if (_zoom > 4.9) {
 			_zoom = 4.9;
 		}
		doZoom();
	}

 	public function zoomOut():Void {
		_zoom -= (_zoom_increment * 10) / (_zoom + 1) ;
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
		doZoom();
	}

 	public function zoomFull():Void {
		_zoom = 0.0;
		doZoom();
		_well.x = 0;
	}
	
	// Zoom to show the current selection
	//
	// sness - This is really difficult because we have to figure out what the
	// _zoom would be given ending points in ms.  Tricky parts include having to
	// take the log base 3 of a quantity halfway though.  Ouch.
 	public function zoomSelection():Void {
		if (_dragger_visible) {
			// Figure out the start and end points of the dragger in ms
			fixDraggerEnds();
			var start_ms:Float = pix2ms(_dragger_start);
			var end_ms:Float = pix2ms(_dragger_end);
			// _view_center_ms = (_view_start_ms + _view_end_ms) / 2;

			setViewStartEnd_ms(start_ms,end_ms);

			doZoom();

			// Change the dragger coordinates to fill the screen
			_dragger_start = ms2pix(_view_start_ms);
			_dragger_end = ms2pix(_view_end_ms);

			redraw();
		}
	}

	////////////////////////////////////////////////////////////////////////////////
	// 
	// Getters and setters for how the visualization images are displayed on the
	// screen
	// 
	////////////////////////////////////////////////////////////////////////////////

	public function setZoom(z:Float):Void {
		_zoom = z;
		calcEdges();
		loadNecessaryImages();
	}

	
	public function setViewStartEnd_ms(start_ms:Float, end_ms:Float):Void {
		_view_start_ms = start_ms;
		_view_end_ms = end_ms;

		// Figure out what zoom level we would need to show those end points
		_zoom_pix_scale_factor = Math.abs((_view_start_ms - _view_end_ms) / _width);

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();

		var o:Float = audio_length / (_zoom_pix_scale_factor * 2400.0);
		var sections:Int;
		if (o < 1) {
			_zoom_level = 0;
			sections = 1;
		} else {
			_zoom_level = Std.int(Math.log(o) / Math.log(3.0))+1;
			sections = Std.int(Math.pow(3,_zoom_level));
		}
		
	    _zoom_value = audio_length / (_zoom_pix_scale_factor * sections * 2400);
		var zoom_frac:Float = (_zoom_value - 0.3333) / 0.6666;
		_zoom = zoom_frac + _zoom_level;

		_zoom_ms_scale_factor = _zoom_value / (audio_length / (sections * 2400.0));

		// Figure out the x-offset
		_well.x = -1.0 * ms2pix(_view_start_ms);
		loadNecessaryImages();
	}

	public function setPosition(pos:Float):Void {
// 		trace("setPosition");
		setViewCenter_ms(pos);
		// sness - This should all be done by a redraw()
		loadNecessaryImages();
		redraw();
	}

	// Recenter the view on center_ms
	public function setViewCenter_ms(center_ms:Float):Void {
		if (_well != null) {
			var center_pix = ms2pix(center_ms);
			var start_pix = center_pix - (_width / 2);
			_well.x = -1.0 * start_pix;
		}
		loadNecessaryImages();
	}

	// Return the leftmost position of the currently visible window
	// in milliseconds
	public function getViewStart_ms():Float {
		calcEdges();
		return _view_start_ms;
	}

	// Return the rightmost position of the currently visible window
	// in milliseconds 
	public function getViewEnd_ms():Float {
		calcEdges();
		return _view_end_ms;
	}
	
	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		calcEdges();
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		calcEdges();
		return ms * _zoom_ms_scale_factor;
	}

	// From the zoom level and _well.x, determine the start, end and center of
	// the current view in ms
	public function calcEdges():Void {
		if (_well != null) {
			_view_start_ms = (_orig_x - _well.x) * _zoom_pix_scale_factor;
			_view_end_ms = _view_start_ms + (_width * _zoom_pix_scale_factor);
			_view_center_ms = _view_start_ms + ((_view_end_ms - _view_start_ms) / 2);

			// The zoom level, an int between 0 and 5
			_zoom_level = Std.int(_zoom);
			if (_zoom_level > GlobalSettings.getMaxZoom()) {
				_zoom_level = GlobalSettings.getMaxZoom();
			}

			// Just the fractional part of zoom_level
			var zoom_frac:Float = (_zoom - _zoom_level);

			// The actual amount we are zooming the images by
			_zoom_value = (zoom_frac * 0.666) + 0.333;

			// The length of the audio file in ms
			_audio_length = GlobalSettings.getAudioLength();
		
			// How many different images are at this zoom level
			_sections = Math.pow(3,_zoom_level);
			
			// How many ms per section
 			_section_size_ms = _audio_length / _sections;

			// _zoom_ms_scale_factor puts all these together into a single number
			// that you can multiply ms by to get pixels
			_zoom_ms_scale_factor = _zoom_value / (_audio_length / (_sections * 2400.0));

			// _zoom_pix_scale_factor puts all these together into a single number
			// that you can multiply pixels by to get ms
			_zoom_pix_scale_factor = _audio_length / (_sections * 2400.0 * _zoom_value);
		}
	}

	// Set the position of the playback bar, the rectangle that shows where
	// audio is currently playing
	public function setPlaybackBar(f:Float):Void {
		_playback_bar_ms = f;
		_playback_bar.x = ms2pix(f) + _well.x;
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	// Utility functions
	//
	////////////////////////////////////////////////////////////////////////////////
	
	// A "r"easonable number of decimal points for trace()
	public function r(f:Float):Float {
		var d:Float = 10000;
		var n:Int = Std.int(f * d);
		return n / d;
	}
	
	// Change a Float to an Int for trace()
	public function ii(f:Float):Int {
		return Std.int(f);
	}

	public function tracer():Void {
		var audio_length:Float = GlobalSettings.getAudioLength();
		// 		trace("wx=" + _well.x + " ds=" + _dragger_start + " de=" + _dragger_end);
		// 		trace("vs=" + Std.int(_view_start_ms) + " ve=" + Std.int(_view_end_ms));
		//  		trace("fvs=" + _view_start_ms / audio_length + " fve=" + _view_end_ms / audio_length);
		// 		if (_well != null) {
		// 			trace("wx=" + _well.x + " ds=" + r(_dragger_start) + " de=" + r(_dragger_end) + " fvs=" + r(_view_start_ms / audio_length) + " fve=" + r(_view_end_ms / audio_length));
		// 		}
		trace("bar=" + r(getPlaybackBar() / audio_length));
	}

	// If the start of the dragger is bigger than the end, swap them
	public function fixDraggerEnds():Void {
		if (_dragger_start > _dragger_end) {
			var tmp:Float = _dragger_start;
			_dragger_start = _dragger_end;
			_dragger_end = tmp;
		}
	}

}


------------------------------ Annotator.hx ------------------------------

** Fri Jul 24 2009 - 10:28:43 AM
   -----------------------------

Almost there

import flash.display.Loader;
import flash.display.Sprite;
import flash.display.Shape;
import flash.events.MouseEvent;
import flash.events.KeyboardEvent;
import flash.events.Event;
import flash.events.ProgressEvent;
import flash.events.HTTPStatusEvent;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.events.EventPhase;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLLoaderDataFormat;
import flash.geom.Point;
import flash.geom.Rectangle;

class Annotator extends Sprite {

	var _well:Sprite;
	var _background:Sprite;
	var _image_container:Sprite;
	var _prediction_container:Sprite;
	var _playback_bar:Sprite;
	// 	var _center_bar:Sprite;

	// The dragger shows the current temporary selected region from the user and
	// an annotation can be created from it.
	var _dragger:Sprite;
	var _dragger_visible:Bool;
	var _dragger_start:Float;
	var _dragger_end:Float;
	var _dragger_start_ms:Float;
	var _dragger_end_ms:Float;

	var _height : Float;
	var _width  : Float;

	var _moving_dragger : Bool;

	// The array of all annotations in this Annotator
	var _annotation_array : Array<Annotation>;

	// The array of all predictions in this Annotator
	var _prediction_array : Array<Prediction>;

	// The current AnnotationExtent that we are dragging
	var _current_ae : AnnotationExtent;

	// The current visualization for this Annotator (e.g. waveform/spectrogram)
	var _visualization_id : String;

	// Loaders to load the index.txt files
	var _visualization_textfile_loader:URLLoader;
	var _annotation_textfile_loader:URLLoader;
	var _prediction_textfile_loader:URLLoader;

	// An array of an array of strings that hold the URLs to the different
	// images for the different zoom levels
	var _image_urls : Array<Array<String>>;

	// The images for the different zoom levels
	var _images : Array<Array<Loader>>;

	// The current zoom level.  1.0 is fully zoomed out.
	var _zoom:Float;
	var _zoom_increment:Float;
	var _zoom_level:Int;
	var _zoom_value:Float;
	var _sections:Float;
	var _audio_length:Float;
	var _section_size_ms:Float;

	var _max_zoom:Int;

	// Has everything been loaded?
	var _total_loaded : Int; // The total number that have been loaded so far
	var _max_loaded : Int; // The maximum number that will be loaded
 	var _loaded : Bool;

	// The area that we can drag the contents of the Annotator in
	var _trackRect : Rectangle; 	

	// The original x value, for figuring out the ends of the visible region
	var _orig_x : Int;

	// The start, end and center of the current view
	var _view_start_ms:Float;
	var _view_end_ms:Float;
	var _view_center_ms:Float;

	var _zoom_ms_scale_factor:Float;  // number that you can multiply ms by to get pixels
	var _zoom_pix_scale_factor:Float; //  number that you can multiply pixels by to get ms

	var _images_ready : Bool;

	// Where the playback bar should be
	var _playback_bar_ms : Float;

	// Have we saved all the changes to the Annotations?
	var _saved : Bool;

	private var _sound_player : SoundPlayer;

	public function new (x_:Int, y_:Int, width_:Int, height_:Int, visualization_id_:String, sound_player_:SoundPlayer) {
		super();

		x = x_;
		y = y_;
		_width = width_;
		_height = height_;
		_orig_x = x_;
		_visualization_id = visualization_id_;
		_sound_player = sound_player_;

		_annotation_array = [];
		_prediction_array = [];

		_moving_dragger = false;
		_saved = true;

		// Start off with a zoom that transforms the whole 2400 pixels into 800
		// visible pixels.
		_zoom = 0.0;
 		_zoom_increment = 0.1;
		doZoom();

		// sness - Just setting these to known values for now, should change
		// this to get the values from GlobalSettings.
		_view_start_ms = 0;
		_view_end_ms = 2881801;
		_view_center_ms = 1440900.5;

		// Set defaults
		_total_loaded = 0;
		_max_loaded = 0;
		_loaded = false;
		_images_ready = false;

		_well = new Sprite();
		_well.graphics.beginFill(0xFFFFFF,1);
		_well.graphics.moveTo(-10000,0);
		_well.graphics.lineTo(10000,0);
		_well.graphics.lineTo(10000,_height);
		_well.graphics.lineTo(-10000,_height);
		_well.graphics.lineTo(-10000,0);
		this.addChild(_well);

 		// The current playback position
 		_playback_bar = new Sprite();
 		_playback_bar.graphics.lineStyle(1,0x333333);		
 		_playback_bar.graphics.moveTo(0,0);
 		_playback_bar.graphics.lineTo(2,0);
 		_playback_bar.graphics.lineTo(2,_height);
 		_playback_bar.graphics.lineTo(0,_height);
 		_playback_bar.graphics.lineTo(0,0);
 		_playback_bar.x = _width / 2;
 		this.addChild(_playback_bar);

		// 		// The center of the Annotator
		// 		_center_bar = new Sprite();
		// 		_center_bar.graphics.lineStyle(1,0x000000);		
		// 		_center_bar.graphics.beginFill(0x000000,1);
		// 		var triangle_size:Float = 2;
		// 		// Top triangle
		// 		_center_bar.graphics.moveTo((_width/2)-triangle_size,0);
		// 		_center_bar.graphics.lineTo((_width/2)+triangle_size,0);
		// 		_center_bar.graphics.lineTo((_width/2)+0.5,triangle_size);
		// 		// Vertical line
		//  		_center_bar.graphics.moveTo(_width/2,0);
		//  		_center_bar.graphics.lineTo((_width/2),_height);
		// 		// Bottom triangle
		// 		_center_bar.graphics.moveTo((_width/2)-triangle_size,_height);
		// 		_center_bar.graphics.lineTo((_width/2)+triangle_size,_height);
		// 		_center_bar.graphics.lineTo((_width/2)+0.5,_height-triangle_size);
		// 		this.addChild(_center_bar);

		// A container for all the annotations we will load
		_image_container = new Sprite();
		_well.addChild(_image_container);

		// A container for all the predictions we will load
		_prediction_container = new Sprite();
		_well.addChild(_prediction_container);

		// sness - This is needed so that we can detect when the user releases the mouse
		// button when they are outside the window, otherwise, if they are dragging the mouse
		// and then release the mouse outside, the window continues to scroll.
		// 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		// 		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		_image_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
		_image_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_image_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
   		_image_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_prediction_container.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_prediction_container.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
  		_prediction_container.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_prediction_container.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

 		_well.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownListener);
 		_well.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveListener);
 		_well.addEventListener(MouseEvent.MOUSE_UP, mouseUpListener);
		_well.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelListener);

		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, mainKeyDownListener);
  		flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, mainKeyUpListener);


		// The grey dragger that allows the user to create new annotations
		_dragger = new Sprite();
		_well.addChild(_dragger);
		
		_dragger_visible = false;

 		// Get the text file for the visualization
		loadVisualization();

 		// Get the text file for the annotations
		var url:String = OrcaAnnotator._annotation_url;
		_annotation_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_annotation_textfile_loader.load(request);
		_annotation_textfile_loader.addEventListener(Event.COMPLETE, annotationTextFileLoaderCompleteHandler);

 		// Get the text file for the predictions
		var url:String = OrcaAnnotator._prediction_url;
		_prediction_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_prediction_textfile_loader.load(request);
		_prediction_textfile_loader.addEventListener(Event.COMPLETE, predictionTextFileLoaderCompleteHandler);
		
		// Create the rectangle that constrains where we can drag the contents
		createTrackRect();

		redraw();

	}

	////////////////////////////////////////
	//
	// Listeners
	//
	////////////////////////////////////////

	// Zoom in and out when the user scrolls the mouse wheel
 	function mouseWheelListener(e:MouseEvent):Void {
		// Remember what the extents of the dragger were before the zoom
		_dragger_start_ms = pix2ms(_dragger_start);
		_dragger_end_ms = pix2ms(_dragger_end);
		trace("before : dsms=" + ii(_dragger_start_ms) + " dems=" + ii(_dragger_end_ms));

		if (e.delta < 0) {
 			_zoom -= _zoom_increment / (_zoom + 1) ;
		} else {
 			_zoom += _zoom_increment / (_zoom + 1);
		}
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
 		if (_zoom > 4.9) {
 			_zoom = 4.9;
 		}
		doZoom();

		// Set the extents of the dragger after the zoom
		_dragger_start = ms2pix(_dragger_start_ms);
		_dragger_end = ms2pix(_dragger_end_ms);
		trace("after: ds=" + ii(_dragger_start) + " de=" + ii(_dragger_end));
		redraw();

	}

 	function mouseDownListener(e:MouseEvent):Void {
		//trace("down");
		// 		if (_well != null) {
		// 			trace("_well.x=" + _well.x);
		// 		}

		// If the ctrl key is pressed, show the dragger, which starts 
		// the process of adding a new annotation
		if (e.ctrlKey) {
			_dragger_visible = true;
			_dragger_start = e.localX;
			_dragger_end = e.localX;
			_moving_dragger = true;
			// sness - This was there from when I ported the code over, not 
			// sure why it was needed.
			// _well.setChildIndex(_dragger, _well.numChildren - 1);
			redraw();
			return;
		} 

		// Find the position of the mouse in ms and et the current playback
		// position to this point
		//
		// sness - FIXME GETTER
		if (!e.shiftKey) {
			calcEdges();
			var pos:Float = e.stageX / _width;
			var mspos:Int = Std.int(_view_start_ms + ((_view_end_ms - _view_start_ms) * pos));
			OrcaAnnotator.setPosition(mspos,true);
			redraw();
		}
		
		// Allow the user to drag the Annotator
		_well.startDrag(false,_trackRect);
 	}

 	function mouseUpListener(e:MouseEvent):Void {
		_moving_dragger = false;
		AnnotationExtent._drag_icon_mouse_down = false;
		this.stopDrag();
		redraw();
 	}

 	function mouseMoveListener(e:MouseEvent):Void {

		// If we are currently dragging the AnnotationExtent drag icon
		if (AnnotationExtent._drag_icon_mouse_down) {
			_current_ae.setPosition(e.stageX - _well.x);
			redrawAllAnnotations();
			return;
		} 

		// Adjust the size of the dragger.  
		//
		// sness - We cheat here a bit by just adjusting the start edge of the
		// dragger, but since it's just a rectangle, it looks the same.  When we
		// turn it into an Annotation later, we check to see if the start and
		// end ends are swapped.
		//
		// sness - FIXME GETTER
		if (_moving_dragger) {
			_dragger_start = e.stageX - _well.x;
			calcEdges();
			loadNecessaryImages();
			redraw();
		}
		// 		calcEdges();
		// 		loadNecessaryImages();
	}

	private function mainKeyDownListener(e:KeyboardEvent):Void {
		// If the dragger is visible, create a new annotation.
		// For its name, give it the character the user just typed
		var key:Int = e.keyCode;
		if (_dragger_visible && key != 16 && key != 17 && key != 18 ) {
			// Check to see if we need to swap _dragger_start and _dragger_end
			// 			if (_dragger_start > _dragger_end) {
			// 				var tmp:Float = _dragger_end;
			// 				_dragger_end = _dragger_start;
			// 				_dragger_start = tmp;
			// 			}
			fixDraggerEnds();

			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
			_dragger_visible = false;
			_saved = false;
			redraw();
		}
	}

	private function mainKeyUpListener(e:KeyboardEvent):Void {
	}

	private function annotationDeleteEventListener(e:Event):Void {
		_annotation_array.remove(e.target);
		_well.removeChild(e.target);
		redrawAllAnnotations();
	}


	////////////////////////////////////////
	//
	// File load completion handlers
	//
	////////////////////////////////////////

	private function loadImageListener(e:Event):Void {
// 		trace("e.target" + e.target + " e.target.loader=" + e.target.loader);
 		var l:Loader = e.target.loader;
//    		_image_container.addChildAt(l.content,0);
//  		l.content.visible = true;
 		l.content.x = Std.parseInt(l.name);
// 		trace("l.content.x=" + l.content.x);
		_total_loaded += 1;
		_loaded = true;
		// sness - We probably don't need to do this, not sure why it was here
		// 
		// sness - Ah... This is probably setting the scaleX property correctly
 		doZoom();
 	}

	private function visualizationTextFileLoaderCompleteHandler(event:Event):Void {
		_image_urls = new Array();
		for (i in 0...6) {
			_image_urls[i] = new Array();
		}

 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _visualization_textfile_loader.data.split('\n');
		
  		// Split the input data file into lines and fill up the _image_urls data
  		// structure with URLs for the different zoom levels
  		for (i in 0...lines.length) {
  			if (lines[i].charAt(0) != "#") {
   				elements = lines[i].split(',');
   				var zoomlevel = Std.parseInt(elements[0]);
   				var index = Std.parseInt(elements[1]);
   				var url = elements[2];
 				if (zoomlevel != null && index != null) {
 					_image_urls[zoomlevel][index] = url;
 					_max_loaded += 1;
 				}
  			}
  		}

 		// Now that we are done loading the text file, load the image files.
 		// Make arrays to contain the loaders
 		_images = new Array();
 		for (i in 0...6) {
 			_images[i] = new Array();
			var sections:Int = Std.int(Math.pow(3,i));
			for (j in 0...sections) {
				_images[i].push(null);
			}
 		}
		_images_ready = true;

		loadNecessaryImages();

	}

	private function annotationTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _annotation_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
				if (id != null && start_ms != null && end_ms != null && name != null) { 
					createAnnotation(id,start_ms,end_ms,name);
				}
			}
		}
	}

	private function predictionTextFileLoaderCompleteHandler(event:Event):Void {
 		var elements:Array<String> = new Array();
 		var lines:Array<String> = _prediction_textfile_loader.data.split('\n');

 		// Split the input data file into lines and fill up the _image_urls data
 		// structure with URLs for the different zoom levels
 		for (i in 0...lines.length) {
 			if (lines[i].charAt(0) != "#") {
  				elements = lines[i].split(',');
  				var id = Std.parseInt(elements[0]);
  				var start_ms = Std.parseInt(elements[1]);
  				var end_ms = Std.parseInt(elements[2]);
  				var name = elements[3];
  				var confidence = Std.parseFloat(elements[4]);
  				var color = Std.parseInt(elements[5]);
				if (id != null && start_ms != null && end_ms != null && name != null && color != null) { 
					createPrediction(id,start_ms,end_ms,name,confidence,color);
				}
			}
		}
	}


	public function loadNecessaryImages():Void {
//   		trace("load");
		if (_images_ready) {

			// sness - FIXME GETTER
			calcEdges();
// 			// How many different images are at this zoom level
// 			var sections:Float = Math.pow(3,_zoom_level);
// 			var audio_length:Float = GlobalSettings.getAudioLength();
		
			// Figure out which images have their start or end edges within _view_start_ms and _view_end_ms
			var start:Float = 0;
			var end:Float = _section_size_ms;

// 			trace("vs=" + _view_start_ms + " ve=" + _view_end_ms);

			for (i in 0..._image_urls[_zoom_level].length) {
//   				trace("iu[z]=" + _image_urls[_zoom_level][i] + " s=" + start + " e=" + end);
				if (((start >= _view_start_ms) && (start <= _view_end_ms)) ||
					((end >= _view_start_ms) && (end <= _view_end_ms)) ||
					((start >= _view_start_ms) && (end >= _view_end_ms))) {
//  					trace("zl=" + _zoom_level + " i=" + i + " s=" + ii(start) + " vs=" + ii(_view_start_ms) + " e=" + ii(end) + " ve=" + ii(_view_end_ms));
					if (_images[_zoom_level][i] == null) {
						loadImage(_zoom_level,i);
					}
				}
				start = end;
				end += _section_size_ms;
			}
		}
	}

	public function loadImage(zoom_level:Int,index:Int):Void {
// 		trace("loadImage zoom_level=" + zoom_level + " index=" + index);
// 		trace("_image_urls[" + zoom_level + "][" + index + "]=" + _image_urls[zoom_level][index]);
		_images[zoom_level][index] = new Loader();

   		_image_container.addChildAt(_images[zoom_level][index],0);

//  		_images[zoom_level][index].visible = false;
		_images[zoom_level][index].name = Std.string(index * 2400);
		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.INIT, loadImageListener);
		_images[zoom_level][index].load(new URLRequest(_image_urls[zoom_level][index]));

		// sness - Debugging
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.OPEN, handleOpen);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, handleProgress);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.COMPLETE, handleComplete);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(HTTPStatusEvent.HTTP_STATUS, handleHttpStatus);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, handleIoError);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, handleSecurityError);
// 		_images[zoom_level][index].contentLoaderInfo.addEventListener(Event.UNLOAD, handleUnload);
	}

	private function handleOpen(e:Event):Void {
		trace("open");
	}

	private function handleProgress(e:Event):Void {
		trace("progress");
	}

	private function handleComplete(e:Event):Void {
		trace("complete");
	}

	private function handleHttpStatus(e:Event):Void {
		trace("httpstatus");
	}

	private function handleIoError(e:Event):Void {
		trace("ioerror");
	}

	private function handleSecurityError(e:Event):Void {
		trace("securityerror");
	}

	private function handleUnload(e:Event):Void {
		trace("unload");
	}



	public function doZoom():Void {
// 		trace("doZoom");
		// 		var old_view_center_ms:Float = _view_center_ms;


		setZoom(_zoom);

		
		// Calculate the positions of the start and edges that are currently visible
		loadNecessaryImages();
		// sness - FIXME GETTER
		// 		calcEdges();

		//
		// Center the view on the current playback position
		//
		setViewCenter_ms(getPlaybackBar());
		

// 		// Hide all the images
//  		if (_loaded) {
// 			for (i in 0..._images.length) {
// 				for (j in 0..._images[i].length) {
// 					if (_images[i][j] != null && _images[i][j].content != null) {
// 						_images[i][j].content.visible = false;
// 					}
// 				}
// 			}
// 		}

// 		// Just show the images in the current zoom_level
//  		if (_loaded) {
//  			for (j in 0..._images[_zoom_level].length) {
// 				if (_images[_zoom_level][j] != null && _images[_zoom_level][j].content != null) {
// 					var shift_x:Float = j * (2400 * _zoom_value);
// 					_images[_zoom_level][j].content.visible = true;
// 					_images[_zoom_level][j].content.scaleX = _zoom_value;
// 					_images[_zoom_level][j].content.x = shift_x;
// 					// 					trace("zoom_level= " + zoom_level + " j= " + j);
// 				}
//  			}
//  		}

		// Get each annotation to update it's start and end ends
		for (n in _annotation_array) {
			n.redraw();
		}

		// Get each prediction to update it's start and end ends
		for (n in _prediction_array) {
			n.redraw();
		}
	}

 	public function redraw():Void {

		// 		trace("redraw()");
		// 		trace("_well.x=" + _well.x);
		//   		trace("s=" + Std.int(_view_start_ms) + " c=" + Std.int(_view_center_ms) + " e=" + Std.int(_view_end_ms));

		// sness - In here we should recenter the view based on the current
		// playback slider position as obtained from OrcaAnnotator.getPosition()

		if (_dragger != null) {
			_dragger.graphics.clear();
			if (_dragger_visible) {
				_dragger.alpha = 0.5;
				_dragger.graphics.beginFill(0xCCCCCC,1);
				_dragger.graphics.moveTo(_dragger_start,0);
				_dragger.graphics.lineTo(_dragger_end,0);
				_dragger.graphics.lineTo(_dragger_end,_height);
				_dragger.graphics.lineTo(_dragger_start,_height);
				_dragger.graphics.lineTo(_dragger_start,0);
			}
		}

		setPlaybackBar(OrcaAnnotator.getPosition());
		// 		_playback_bar.x = ms2pix(OrcaAnnotator.getPosition()) + _well.x;
		
		// sness - Not sure if this is necessary to do this on redraw, and
		// anyways should only do when dragging, when start/end has changed,
		// zoom has changed or center has changed.
// 		loadNecessaryImages();

 		if (_loaded && _images != null) {

			// Hide all the images
			for (i in 0..._images.length) {
				for (j in 0..._images[i].length) {
					if (_images[i][j] != null && _images[i][j].content != null) {
						_images[i][j].content.visible = false;
					}
				}
			}

			// Just show the images in the current zoom_level
 			for (j in 0..._images[_zoom_level].length) {
				if (_images[_zoom_level][j] != null && _images[_zoom_level][j].content != null) {
					var shift_x:Float = j * (2400 * _zoom_value);
					_images[_zoom_level][j].content.visible = true;
					_images[_zoom_level][j].content.scaleX = _zoom_value;
					_images[_zoom_level][j].content.x = shift_x;
					// 					trace("zoom_level= " + zoom_level + " j= " + j);
				}
 			}
 		}
		
 	}

	public function newAnnotation() {
		if (_dragger_visible) {
			fixDraggerEnds();
			createAnnotation(0,pix2ms(_dragger_start),pix2ms(_dragger_end),"");
		}
	}

	// Create a new annotation
	function createAnnotation(id:Int,start_ms:Float,end_ms:Float,title:String) {
 		var annotation = new Annotation(id,start_ms,end_ms,title,this);
 		var i:Int = _annotation_array.push(annotation);
 		annotation._index = i;
 		annotation.addEventListener(Annotation.DELETE_ANNOTATION_EVENT,annotationDeleteEventListener);
 		_well.addChild(annotation);
	}

	// Create a new prediction
	function createPrediction(id:Int,start_ms:Float,end_ms:Float,title:String,confidence:Float,color:Int) {
 		var prediction = new Prediction(id,start_ms,end_ms,title,confidence,color,this);
 		var i:Int = _prediction_array.push(prediction);
 		prediction._index = i;
 		_prediction_container.addChild(prediction);
	}

	// Redraw all the annotations in _annotation_array
	function redrawAllAnnotations() {
		determineAnnotationYPositions();
		for (n in _annotation_array) {
			n.redraw();
		}
	}

	// Figure out y position of all annotations
	//
	// sness - This code was lifted from Audacity.  I don't really like how it
	// behaves, it would be nice to do it properly later, but there are a lot of
	// special cases to handle.
	function determineAnnotationYPositions() {
		var MAX_NUM_ROWS = 10;
		var nRows:Int = MAX_NUM_ROWS;
		
		var xUsed : Array<Float> = new Array();
		for (i in 0...MAX_NUM_ROWS) {
			xUsed.push(-1.0);
		}
		
		var iRow:Int;
		var nRowsUsed:Int = 0;
		var yRowHeight:Float = 10.0;
		for (i in 0..._annotation_array.length) {
			iRow = 0;
			_annotation_array[i]._y=-1.0;
			while( (iRow<nRowsUsed) && (xUsed[iRow] != _annotation_array[i]._start )) {
				iRow++;
			}
			if( iRow >= nRowsUsed ) {
				iRow=0;
				while( (iRow<nRows) && (xUsed[iRow] > _annotation_array[i]._start ))
					iRow++;
			}
			
			if( iRow<nRows ) {
				if( iRow >= nRowsUsed )
					nRowsUsed=iRow+1;
				_annotation_array[i]._row=iRow;
				xUsed[iRow]=_annotation_array[i]._start;

				if(xUsed[iRow] < _annotation_array[i]._end) 
					xUsed[iRow]=_annotation_array[i]._end;
			}
		}

		var row_height:Float = _height / nRowsUsed;
		var start = row_height / 2;
		for (n in _annotation_array) {
			n._y = start + (n._row * row_height);
		}

	}

	// Create the rectangle that constrains where we can drag the contents
	private function createTrackRect():Void {
		// Set the width to zero for strictly vertical dragging
 		_trackRect = new Rectangle(-1000000.0, 0, _width + 1000000, 0); 
	}


	//
	// Getters and setters
	//
	public function setCurrentAnnotationExtent(ae:AnnotationExtent):Void {
		_current_ae = ae;
	}

	public function getHeight():Float {
		return _height;
	}
	
	//
	// Save all annotations back to the web server using a POST request to 
	// the /annotations/update method.
	//
	// We package up all the annotations in a text file of the form:
	// id,start_ms,end_ms,name
	//
	public function saveAnnotations():Void {
		// Build a string of the data in all the annotations
		var output:String = "annotations=";
		for (n in _annotation_array) {
			output += n.to_string() + "\n";
		}
		// Send the string to the web server
		var request:URLRequest = new URLRequest("/annotations/update");
		request.method = URLRequestMethod.POST;
		request.data = output;

		var loader:URLLoader = new URLLoader();
		loader.dataFormat = URLLoaderDataFormat.TEXT;
		loader.addEventListener(Event.COMPLETE, updateLoaderCompleteHandler);
		loader.load(request);

	}

	// Called when the web server returns a response to us trying to save the
	// annotations.  The web server should return the string "update complete "
	// if everything worked.
	private function updateLoaderCompleteHandler(event:Event):Void {
		if (event.target.data != "update complete ") {
			trace("error in saving annotations.  tell sness@sness.net");
		}
		_saved = true;
	}
	
	// Have all the annotations been saved back to the web server?
	public function setSaved(b:Bool):Void {
		_saved = b;
	}

	public function getSaved():Bool {
		return _saved;
	}

	// Load a specific visualization from the web server, for
	// example, the waveform or spectrogram view
	public function loadVisualization() {
		_images_ready = false;
		var url:String = OrcaAnnotator._visualization_url + "/index.txt";
 		_visualization_textfile_loader = new URLLoader();
		var request:URLRequest = new URLRequest(url);
		_visualization_textfile_loader.load(request);
		_visualization_textfile_loader.addEventListener(Event.COMPLETE, visualizationTextFileLoaderCompleteHandler);
	}

	// Called from the main OrcaAnnotator class by Javascript when the 
	// user requests to see a different visualization
	public function reloadVisualization() {
		for(i in 0..._image_container.numChildren) {
			_image_container.removeChildAt(0);
		}

		_images = new Array();
		_image_urls = new Array();
		loadVisualization();
	}

 	public function zoomIn():Void {
		_zoom += (_zoom_increment * 10) / (_zoom + 1);
 		if (_zoom > 4.9) {
 			_zoom = 4.9;
 		}
		doZoom();
	}

 	public function zoomOut():Void {
		_zoom -= (_zoom_increment * 10) / (_zoom + 1) ;
		if (_zoom < 0.0) {
			_zoom = 0.0;
		}
		doZoom();
	}

 	public function zoomFull():Void {
		_zoom = 0.0;
		doZoom();
		_well.x = 0;
	}
	
	// Zoom to show the current selection
	//
	// sness - This is really difficult because we have to figure out what the
	// _zoom would be given ending points in ms.  Tricky parts include having to
	// take the log base 3 of a quantity halfway though.  Ouch.
 	public function zoomSelection():Void {
		if (_dragger_visible) {
			// Figure out the start and end points of the dragger in ms
			fixDraggerEnds();
			var start_ms:Float = pix2ms(_dragger_start);
			var end_ms:Float = pix2ms(_dragger_end);
			// _view_center_ms = (_view_start_ms + _view_end_ms) / 2;

			setViewStartEnd_ms(start_ms,end_ms);

			doZoom();

			// Change the dragger coordinates to fill the screen
			_dragger_start = ms2pix(_view_start_ms);
			_dragger_end = ms2pix(_view_end_ms);

			redraw();
		}
	}

	////////////////////////////////////////////////////////////////////////////////
	// 
	// Getters and setters for how the visualization images are displayed on the
	// screen
	// 
	////////////////////////////////////////////////////////////////////////////////

	public function setZoom(z:Float):Void {
		_zoom = z;
		calcEdges();
		loadNecessaryImages();
	}

	
	public function setViewStartEnd_ms(start_ms:Float, end_ms:Float):Void {
		_view_start_ms = start_ms;
		_view_end_ms = end_ms;

		// Figure out what zoom level we would need to show those end points
		_zoom_pix_scale_factor = Math.abs((_view_start_ms - _view_end_ms) / _width);

		// The length of the audio file in ms
		var audio_length:Float = GlobalSettings.getAudioLength();

		var o:Float = audio_length / (_zoom_pix_scale_factor * 2400.0);
		var sections:Int;
		if (o < 1) {
			_zoom_level = 0;
			sections = 1;
		} else {
			_zoom_level = Std.int(Math.log(o) / Math.log(3.0))+1;
			sections = Std.int(Math.pow(3,_zoom_level));
		}
		
	    _zoom_value = audio_length / (_zoom_pix_scale_factor * sections * 2400);
		var zoom_frac:Float = (_zoom_value - 0.3333) / 0.6666;
		_zoom = zoom_frac + _zoom_level;

		_zoom_ms_scale_factor = _zoom_value / (audio_length / (sections * 2400.0));

		// Figure out the x-offset
		_well.x = -1.0 * ms2pix(_view_start_ms);
		loadNecessaryImages();
	}

	public function setPosition(pos:Float):Void {
// 		trace("setPosition");
		setViewCenter_ms(pos);
		// sness - This should all be done by a redraw()
		loadNecessaryImages();
		redraw();
	}

	// Recenter the view on center_ms
	public function setViewCenter_ms(center_ms:Float):Void {
		if (_well != null) {
			var center_pix = ms2pix(center_ms);
			var start_pix = center_pix - (_width / 2);
			_well.x = -1.0 * start_pix;
		}
		loadNecessaryImages();
	}

	// Return the leftmost position of the currently visible window
	// in milliseconds
	public function getViewStart_ms():Float {
		calcEdges();
		return _view_start_ms;
	}

	// Return the rightmost position of the currently visible window
	// in milliseconds 
	public function getViewEnd_ms():Float {
		calcEdges();
		return _view_end_ms;
	}
	
	// Convert a value in pixels from the current view into milliseconds
	public function pix2ms(pix:Float):Float {
		calcEdges();
		return pix * _zoom_pix_scale_factor;
	}

	// Convert a value in milliseconds into pixels from the current view
	public function ms2pix(ms:Float):Float {
		calcEdges();
		return ms * _zoom_ms_scale_factor;
	}

	// From the zoom level and _well.x, determine the start, end and center of
	// the current view in ms
	public function calcEdges():Void {
		if (_well != null) {
			_view_start_ms = (_orig_x - _well.x) * _zoom_pix_scale_factor;
			_view_end_ms = _view_start_ms + (_width * _zoom_pix_scale_factor);
			_view_center_ms = _view_start_ms + ((_view_end_ms - _view_start_ms) / 2);

			// The zoom level, an int between 0 and 5
			_zoom_level = Std.int(_zoom);
			if (_zoom_level > GlobalSettings.getMaxZoom()) {
				_zoom_level = GlobalSettings.getMaxZoom();
			}

			// Just the fractional part of zoom_level
			var zoom_frac:Float = (_zoom - _zoom_level);

			// The actual amount we are zooming the images by
			_zoom_value = (zoom_frac * 0.666) + 0.333;

			// The length of the audio file in ms
			_audio_length = GlobalSettings.getAudioLength();
		
			// How many different images are at this zoom level
			_sections = Math.pow(3,_zoom_level);
			
			// How many ms per section
 			_section_size_ms = _audio_length / _sections;

			// _zoom_ms_scale_factor puts all these together into a single number
			// that you can multiply ms by to get pixels
			_zoom_ms_scale_factor = _zoom_value / (_audio_length / (_sections * 2400.0));

			// _zoom_pix_scale_factor puts all these together into a single number
			// that you can multiply pixels by to get ms
			_zoom_pix_scale_factor = _audio_length / (_sections * 2400.0 * _zoom_value);
		}
	}

	// Set the position of the playback bar, the rectangle that shows where
	// audio is currently playing
	public function setPlaybackBar(f:Float):Void {
		if (_playback_bar != null) {
			_playback_bar_ms = f;
			_playback_bar.x = ms2pix(f) + _well.x;
		}
	}

	public function getPlaybackBar():Float {
		return _playback_bar_ms;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	// Utility functions
	//
	////////////////////////////////////////////////////////////////////////////////
	
	// A "r"easonable number of decimal points for trace()
	public function r(f:Float):Float {
		var d:Float = 10000;
		var n:Int = Std.int(f * d);
		return n / d;
	}
	
	// Change a Float to an Int for trace()
	public function ii(f:Float):Int {
		return Std.int(f);
	}

	public function tracer():Void {
		var audio_length:Float = GlobalSettings.getAudioLength();
		// 		trace("wx=" + _well.x + " ds=" + _dragger_start + " de=" + _dragger_end);
		// 		trace("vs=" + Std.int(_view_start_ms) + " ve=" + Std.int(_view_end_ms));
		//  		trace("fvs=" + _view_start_ms / audio_length + " fve=" + _view_end_ms / audio_length);
		// 		if (_well != null) {
		// 			trace("wx=" + _well.x + " ds=" + r(_dragger_start) + " de=" + r(_dragger_end) + " fvs=" + r(_view_start_ms / audio_length) + " fve=" + r(_view_end_ms / audio_length));
		// 		}
// 		trace("bar=" + r(getPlaybackBar() / audio_length));
		trace("ds=" + ii(_dragger_start) + " de=" + ii(_dragger_end) + "dsms=" + ii(_dragger_start_ms) + " dems=" + ii(_dragger_end_ms)); 
	}

	// If the start of the dragger is bigger than the end, swap them
	public function fixDraggerEnds():Void {
		if (_dragger_start > _dragger_end) {
			var tmp:Float = _dragger_start;
			_dragger_start = _dragger_end;
			_dragger_end = tmp;
		}
	}

}


------------------------------ Annotator.hx ------------------------------

	public function setZoom(z:Float):Void {

		// Remember what the extents of the dragger were before the zoom
		_dragger_start_ms = pix2ms(_dragger_start);
		_dragger_end_ms = pix2ms(_dragger_end);
// 		trace("before : dsms=" + ii(_dragger_start_ms) + " dems=" + ii(_dragger_end_ms));

		_zoom = z;
		calcEdges();
		loadNecessaryImages();

		// Set the extents of the dragger after the zoom
		_dragger_start = ms2pix(_dragger_start_ms);
		_dragger_end = ms2pix(_dragger_end_ms);
// 		trace("after: ds=" + ii(_dragger_start) + " de=" + ii(_dragger_end));

	}
